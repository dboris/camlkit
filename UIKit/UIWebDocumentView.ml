(* auto-generated, do not modify *)

open Runtime
open Objc

[@@@ocaml.warning "-33"]
open Foundation
open CoreAnimation
open CoreText

(** Apple docs: {{:https://developer.apple.com/documentation/uikit/uiwebdocumentview?language=objc}UIWebDocumentView} *)

let self = get_class "UIWebDocumentView"

let actionDidFinish self = msg_send ~self ~cmd:(selector "actionDidFinish") ~typ:(returning void)
let addInputString x self = msg_send ~self ~cmd:(selector "addInputString:") ~typ:(id @-> returning void) x
let addInputString' x ~withFlags self = msg_send ~self ~cmd:(selector "addInputString:withFlags:") ~typ:(id @-> ullong @-> returning void) x (ULLong.of_int withFlags)
let alwaysConstrainsScale self = msg_send ~self ~cmd:(selector "alwaysConstrainsScale") ~typ:(returning bool)
let approximateNodeAtViewportLocation x self = msg_send ~self ~cmd:(selector "approximateNodeAtViewportLocation:") ~typ:((ptr CGPoint.t) @-> returning id) x
let asText self = msg_send ~self ~cmd:(selector "asText") ~typ:(returning id)
let assistFormNode x self = msg_send ~self ~cmd:(selector "assistFormNode:") ~typ:(id @-> returning void) x
let attemptClick x self = msg_send ~self ~cmd:(selector "attemptClick:") ~typ:(id @-> returning void) x
let automaticallySelectedOverlay self = msg_send ~self ~cmd:(selector "automaticallySelectedOverlay") ~typ:(returning id)
let autoscrollContentFrame self = msg_send ~self ~cmd:(selector "autoscrollContentFrame") ~typ:(returning CGRect.t)
let autoscrollContentOffset self = msg_send ~self ~cmd:(selector "autoscrollContentOffset") ~typ:(returning CGPoint.t)
let autoscrollDragFrame self = msg_send ~self ~cmd:(selector "autoscrollDragFrame") ~typ:(returning CGRect.t)
let baseWritingDirectionForPosition x ~inDirection self = msg_send ~self ~cmd:(selector "baseWritingDirectionForPosition:inDirection:") ~typ:(id @-> llong @-> returning llong) x (LLong.of_int inDirection)
let becomeFirstResponder self = msg_send ~self ~cmd:(selector "becomeFirstResponder") ~typ:(returning bool)
let becomesEditableWithGestures self = msg_send ~self ~cmd:(selector "becomesEditableWithGestures") ~typ:(returning bool)
let beginFloatingCursorAtPoint x self = msg_send ~self ~cmd:(selector "beginFloatingCursorAtPoint:") ~typ:(CGPoint.t @-> returning void) x
let beginPrintModeForFrame x ~withSize ~startOffset ~minimumLayoutWidth ~maximumLayoutWidth ~tileClippedContent self = msg_send ~self ~cmd:(selector "beginPrintModeForFrame:withSize:startOffset:minimumLayoutWidth:maximumLayoutWidth:tileClippedContent:") ~typ:(id @-> CGSize.t @-> double @-> double @-> double @-> bool @-> returning id) x withSize startOffset minimumLayoutWidth maximumLayoutWidth tileClippedContent
let beginPrintModeForFrame' x ~withWidth ~height ~startOffset ~shrinkToFit ~tileClippedContent self = msg_send ~self ~cmd:(selector "beginPrintModeForFrame:withWidth:height:startOffset:shrinkToFit:tileClippedContent:") ~typ:(id @-> double @-> double @-> double @-> bool @-> bool @-> returning id) x withWidth height startOffset shrinkToFit tileClippedContent
let beginPrintModeWithSize x ~startOffset ~minimumLayoutWidth ~maximumLayoutWidth ~tileClippedContent self = msg_send ~self ~cmd:(selector "beginPrintModeWithSize:startOffset:minimumLayoutWidth:maximumLayoutWidth:tileClippedContent:") ~typ:(CGSize.t @-> double @-> double @-> double @-> bool @-> returning id) x startOffset minimumLayoutWidth maximumLayoutWidth tileClippedContent
let beginPrintModeWithWidth x ~height ~startOffset ~shrinkToFit ~forFrame self = msg_send ~self ~cmd:(selector "beginPrintModeWithWidth:height:startOffset:shrinkToFit:forFrame:") ~typ:(double @-> double @-> double @-> bool @-> id @-> returning id) x height startOffset shrinkToFit forFrame
let beginPrintModeWithWidth' x ~height ~startOffset ~shrinkToFit ~tileClippedContent ~forFrame self = msg_send ~self ~cmd:(selector "beginPrintModeWithWidth:height:startOffset:shrinkToFit:tileClippedContent:forFrame:") ~typ:(double @-> double @-> double @-> bool @-> bool @-> id @-> returning id) x height startOffset shrinkToFit tileClippedContent forFrame
let beginSelectionChange self = msg_send ~self ~cmd:(selector "beginSelectionChange") ~typ:(returning void)
let beginningOfDocument self = msg_send ~self ~cmd:(selector "beginningOfDocument") ~typ:(returning id)
let canBecomeFirstResponder self = msg_send ~self ~cmd:(selector "canBecomeFirstResponder") ~typ:(returning bool)
let canPerformAction x ~withSender self = msg_send ~self ~cmd:(selector "canPerformAction:withSender:") ~typ:(_SEL @-> id @-> returning bool) x withSender
let canResignFirstResponder self = msg_send ~self ~cmd:(selector "canResignFirstResponder") ~typ:(returning bool)
let cancelAutoscroll self = msg_send ~self ~cmd:(selector "cancelAutoscroll") ~typ:(returning void)
let cancelInteraction self = msg_send ~self ~cmd:(selector "cancelInteraction") ~typ:(returning void)
let cancelInteractionWithImmediateDisplay x self = msg_send ~self ~cmd:(selector "cancelInteractionWithImmediateDisplay:") ~typ:(bool @-> returning void) x
let cancelMouseTracking self = msg_send ~self ~cmd:(selector "cancelMouseTracking") ~typ:(returning bool)
let cancelTouchTracking self = msg_send ~self ~cmd:(selector "cancelTouchTracking") ~typ:(returning bool)
let caretInsets self = msg_send ~self ~cmd:(selector "caretInsets") ~typ:(returning UIEdgeInsets.t)
let caretRect self = msg_send ~self ~cmd:(selector "caretRect") ~typ:(returning CGRect.t)
let caretRectForPosition x self = msg_send ~self ~cmd:(selector "caretRectForPosition:") ~typ:(id @-> returning CGRect.t) x
let caretRectForVisiblePosition x self = msg_send ~self ~cmd:(selector "caretRectForVisiblePosition:") ~typ:(id @-> returning CGRect.t) x
let characterAfterCaretSelection self = msg_send ~self ~cmd:(selector "characterAfterCaretSelection") ~typ:(returning ushort)
let characterInRelationToCaretSelection x self = msg_send ~self ~cmd:(selector "characterInRelationToCaretSelection:") ~typ:(int @-> returning ushort) x
let characterRangeAtPoint x self = msg_send ~self ~cmd:(selector "characterRangeAtPoint:") ~typ:(CGPoint.t @-> returning id) x
let characterRangeByExtendingPosition x ~inDirection self = msg_send ~self ~cmd:(selector "characterRangeByExtendingPosition:inDirection:") ~typ:(id @-> llong @-> returning id) x (LLong.of_int inDirection)
let checkSpellingOfString x self = msg_send ~self ~cmd:(selector "checkSpellingOfString:") ~typ:(id @-> returning id) x
let clearInteractionTimer self = msg_send ~self ~cmd:(selector "clearInteractionTimer") ~typ:(returning void)
let clearMarkedText self = msg_send ~self ~cmd:(selector "clearMarkedText") ~typ:(returning void)
let clearRangedSelectionInitialExtent self = msg_send ~self ~cmd:(selector "clearRangedSelectionInitialExtent") ~typ:(returning void)
let clearSelection self = msg_send ~self ~cmd:(selector "clearSelection") ~typ:(returning void)
let clearWKFirstResponder self = msg_send ~self ~cmd:(selector "clearWKFirstResponder") ~typ:(returning bool)
let closestCaretRectInMarkedTextRangeForPoint x self = msg_send ~self ~cmd:(selector "closestCaretRectInMarkedTextRangeForPoint:") ~typ:(CGPoint.t @-> returning CGRect.t) x
let closestPositionToPoint x self = msg_send ~self ~cmd:(selector "closestPositionToPoint:") ~typ:(CGPoint.t @-> returning id) x
let closestPositionToPoint' x ~withinRange self = msg_send ~self ~cmd:(selector "closestPositionToPoint:withinRange:") ~typ:(CGPoint.t @-> id @-> returning id) x withinRange
let collapseSelection self = msg_send ~self ~cmd:(selector "collapseSelection") ~typ:(returning void)
let comparePosition x ~toPosition self = msg_send ~self ~cmd:(selector "comparePosition:toPosition:") ~typ:(id @-> id @-> returning llong) x toPosition
let completeInteraction self = msg_send ~self ~cmd:(selector "completeInteraction") ~typ:(returning void)
let computeClientAndGlobalPointsForSession x ~outClientPoint ~outGlobalPoint self = msg_send ~self ~cmd:(selector "computeClientAndGlobalPointsForSession:outClientPoint:outGlobalPoint:") ~typ:(id @-> (ptr CGPoint.t) @-> (ptr CGPoint.t) @-> returning void) x outClientPoint outGlobalPoint
let computeRectForElement x ~withHighligh ~isInverted self = msg_send ~self ~cmd:(selector "computeRectForElement:withHighligh:isInverted:") ~typ:(id @-> id @-> bool @-> returning CGRect.t) x withHighligh isInverted
let confirmMarkedText x self = msg_send ~self ~cmd:(selector "confirmMarkedText:") ~typ:(id @-> returning void) x
let considerHeightForDoubleTap self = msg_send ~self ~cmd:(selector "considerHeightForDoubleTap") ~typ:(returning bool)
let constrainedPoint x self = msg_send ~self ~cmd:(selector "constrainedPoint:") ~typ:(CGPoint.t @-> returning CGPoint.t) x
let contentFrameForView x self = msg_send ~self ~cmd:(selector "contentFrameForView:") ~typ:(id @-> returning CGRect.t) x
let contentView self = msg_send ~self ~cmd:(selector "contentView") ~typ:(returning id)
let continueInteractionWithLocation x self = msg_send ~self ~cmd:(selector "continueInteractionWithLocation:") ~typ:(CGPoint.t @-> returning void) x
let convertCaretRect x self = msg_send ~self ~cmd:(selector "convertCaretRect:") ~typ:(CGRect.t @-> returning CGRect.t) x
let convertPoint x ~fromFrame self = msg_send ~self ~cmd:(selector "convertPoint:fromFrame:") ~typ:(CGPoint.t @-> id @-> returning CGPoint.t) x fromFrame
let convertPoint' x ~toFrame self = msg_send ~self ~cmd:(selector "convertPoint:toFrame:") ~typ:(CGPoint.t @-> id @-> returning CGPoint.t) x toFrame
let convertPointToSelectedFrameCoordinates x self = msg_send ~self ~cmd:(selector "convertPointToSelectedFrameCoordinates:") ~typ:(CGPoint.t @-> returning CGPoint.t) x
let convertRect x ~fromFrame self = msg_send ~self ~cmd:(selector "convertRect:fromFrame:") ~typ:(CGRect.t @-> id @-> returning CGRect.t) x fromFrame
let convertRect' x ~toFrame self = msg_send ~self ~cmd:(selector "convertRect:toFrame:") ~typ:(CGRect.t @-> id @-> returning CGRect.t) x toFrame
let convertRectFromSelectedFrameCoordinates x self = msg_send ~self ~cmd:(selector "convertRectFromSelectedFrameCoordinates:") ~typ:(CGRect.t @-> returning CGRect.t) x
let convertRectWithDocumentScale x self = msg_send ~self ~cmd:(selector "convertRectWithDocumentScale:") ~typ:(CGRect.t @-> returning CGRect.t) x
let copy x self = msg_send ~self ~cmd:(selector "copy:") ~typ:(id @-> returning void) x
let currentDocumentScale self = msg_send ~self ~cmd:(selector "currentDocumentScale") ~typ:(returning double)
let currentDragCaretRect self = msg_send ~self ~cmd:(selector "currentDragCaretRect") ~typ:(returning CGRect.t)
let currentDragSourceAction self = msg_send ~self ~cmd:(selector "currentDragSourceAction") ~typ:(returning ullong)
let cut x self = msg_send ~self ~cmd:(selector "cut:") ~typ:(id @-> returning void) x
let dataDetectorTypes self = msg_send ~self ~cmd:(selector "dataDetectorTypes") ~typ:(returning ullong)
let dealloc self = msg_send ~self ~cmd:(selector "dealloc") ~typ:(returning void)
let decreaseSize x self = msg_send ~self ~cmd:(selector "decreaseSize:") ~typ:(id @-> returning void) x
let deepestNodeAtViewportLocation x self = msg_send ~self ~cmd:(selector "deepestNodeAtViewportLocation:") ~typ:(CGPoint.t @-> returning id) x
let deferInteraction self = msg_send ~self ~cmd:(selector "deferInteraction") ~typ:(returning void)
let deferredBecomeFirstResponder self = msg_send ~self ~cmd:(selector "deferredBecomeFirstResponder") ~typ:(returning void)
let delegate self = msg_send ~self ~cmd:(selector "delegate") ~typ:(returning id)
let deleteBackward self = msg_send ~self ~cmd:(selector "deleteBackward") ~typ:(returning void)
let deleteFromInput self = msg_send ~self ~cmd:(selector "deleteFromInput") ~typ:(returning void)
let deleteFromInputWithFlags x self = msg_send ~self ~cmd:(selector "deleteFromInputWithFlags:") ~typ:(ullong @-> returning void) (ULLong.of_int x)
let detectsPhoneNumbers self = msg_send ~self ~cmd:(selector "detectsPhoneNumbers") ~typ:(returning bool)
let deviceOrientation self = msg_send ~self ~cmd:(selector "deviceOrientation") ~typ:(returning int)
let dictationInterpretations self = msg_send ~self ~cmd:(selector "dictationInterpretations") ~typ:(returning id)
let dictationResultMetadataForRange x self = msg_send ~self ~cmd:(selector "dictationResultMetadataForRange:") ~typ:(id @-> returning id) x
let didEndScroll self = msg_send ~self ~cmd:(selector "didEndScroll") ~typ:(returning void)
let didEndZoom self = msg_send ~self ~cmd:(selector "didEndZoom") ~typ:(returning void)
let didFirstVisuallyNonEmptyLayout self = msg_send ~self ~cmd:(selector "didFirstVisuallyNonEmptyLayout") ~typ:(returning bool)
let didMoveToSuperview self = msg_send ~self ~cmd:(selector "didMoveToSuperview") ~typ:(returning void)
let didRemovePlugInView x self = msg_send ~self ~cmd:(selector "didRemovePlugInView:") ~typ:(id @-> returning void) x
let didRotateInteractionSheet self = msg_send ~self ~cmd:(selector "didRotateInteractionSheet") ~typ:(returning void)
let didZoom self = msg_send ~self ~cmd:(selector "didZoom") ~typ:(returning void)
let disableClearsOnInsertion self = msg_send ~self ~cmd:(selector "disableClearsOnInsertion") ~typ:(returning void)
let documentBounds self = msg_send ~self ~cmd:(selector "documentBounds") ~typ:(returning CGRect.t)
let documentType self = msg_send ~self ~cmd:(selector "documentType") ~typ:(returning int)
let doubleTapRect self = msg_send ~self ~cmd:(selector "doubleTapRect") ~typ:(returning CGRect.t)
let doubleTapRectIsReplaced self = msg_send ~self ~cmd:(selector "doubleTapRectIsReplaced") ~typ:(returning bool)
let doubleTapScalesForSize x self = msg_send ~self ~cmd:(selector "doubleTapScalesForSize:") ~typ:(CGSize.t @-> returning void) x
let dragInteraction self = msg_send ~self ~cmd:(selector "dragInteraction") ~typ:(returning id)
let dragInteraction1 x ~itemsForBeginningSession self = msg_send ~self ~cmd:(selector "dragInteraction:itemsForBeginningSession:") ~typ:(id @-> id @-> returning id) x itemsForBeginningSession
let dragInteraction2 x ~sessionWillBegin self = msg_send ~self ~cmd:(selector "dragInteraction:sessionWillBegin:") ~typ:(id @-> id @-> returning void) x sessionWillBegin
let dragInteraction3 x ~previewForCancellingItem ~withDefault self = msg_send ~self ~cmd:(selector "dragInteraction:previewForCancellingItem:withDefault:") ~typ:(id @-> id @-> id @-> returning id) x previewForCancellingItem withDefault
let dragInteraction4 x ~previewForLiftingItem ~session self = msg_send ~self ~cmd:(selector "dragInteraction:previewForLiftingItem:session:") ~typ:(id @-> id @-> id @-> returning id) x previewForLiftingItem session
let dragInteraction5 x ~session ~didEndWithOperation self = msg_send ~self ~cmd:(selector "dragInteraction:session:didEndWithOperation:") ~typ:(id @-> id @-> ullong @-> returning void) x session (ULLong.of_int didEndWithOperation)
let dragInteraction6 x ~willAnimateLiftWithAnimator ~session self = msg_send ~self ~cmd:(selector "dragInteraction:willAnimateLiftWithAnimator:session:") ~typ:(id @-> id @-> id @-> returning void) x willAnimateLiftWithAnimator session
let dragInteractionEnabled self = msg_send ~self ~cmd:(selector "dragInteractionEnabled") ~typ:(returning bool)
let draggedLinkTitle self = msg_send ~self ~cmd:(selector "draggedLinkTitle") ~typ:(returning id)
let draggedLinkURL self = msg_send ~self ~cmd:(selector "draggedLinkURL") ~typ:(returning id)
let drawPage x ~withPaginationInfo self = msg_send ~self ~cmd:(selector "drawPage:withPaginationInfo:") ~typ:(ullong @-> id @-> returning void) (ULLong.of_int x) withPaginationInfo
let dropInteraction self = msg_send ~self ~cmd:(selector "dropInteraction") ~typ:(returning id)
let dropInteraction1 x ~concludeDrop self = msg_send ~self ~cmd:(selector "dropInteraction:concludeDrop:") ~typ:(id @-> id @-> returning void) x concludeDrop
let dropInteraction2 x ~performDrop self = msg_send ~self ~cmd:(selector "dropInteraction:performDrop:") ~typ:(id @-> id @-> returning void) x performDrop
let dropInteraction3 x ~sessionDidEnd self = msg_send ~self ~cmd:(selector "dropInteraction:sessionDidEnd:") ~typ:(id @-> id @-> returning void) x sessionDidEnd
let dropInteraction4 x ~sessionDidEnter self = msg_send ~self ~cmd:(selector "dropInteraction:sessionDidEnter:") ~typ:(id @-> id @-> returning void) x sessionDidEnter
let dropInteraction5 x ~sessionDidExit self = msg_send ~self ~cmd:(selector "dropInteraction:sessionDidExit:") ~typ:(id @-> id @-> returning void) x sessionDidExit
let dropInteraction6 x ~sessionDidUpdate self = msg_send ~self ~cmd:(selector "dropInteraction:sessionDidUpdate:") ~typ:(id @-> id @-> returning id) x sessionDidUpdate
let dropInteraction7 x ~item ~willAnimateDropWithAnimator self = msg_send ~self ~cmd:(selector "dropInteraction:item:willAnimateDropWithAnimator:") ~typ:(id @-> id @-> id @-> returning void) x item willAnimateDropWithAnimator
let dropInteraction8 x ~previewForDroppingItem ~withDefault self = msg_send ~self ~cmd:(selector "dropInteraction:previewForDroppingItem:withDefault:") ~typ:(id @-> id @-> id @-> returning id) x previewForDroppingItem withDefault
let editDragPreviewForTextIndicator x self = msg_send ~self ~cmd:(selector "editDragPreviewForTextIndicator:") ~typ:(id @-> returning id) x
let effectiveDataDetectorTypes self = msg_send ~self ~cmd:(selector "effectiveDataDetectorTypes") ~typ:(returning ullong)
let enclosingScrollView self = msg_send ~self ~cmd:(selector "enclosingScrollView") ~typ:(returning id)
let endFloatingCursor self = msg_send ~self ~cmd:(selector "endFloatingCursor") ~typ:(returning void)
let endOfDocument self = msg_send ~self ~cmd:(selector "endOfDocument") ~typ:(returning id)
let endPrintMode self = msg_send ~self ~cmd:(selector "endPrintMode") ~typ:(returning void)
let endSelectionChange self = msg_send ~self ~cmd:(selector "endSelectionChange") ~typ:(returning void)
let ensureSelection self = msg_send ~self ~cmd:(selector "ensureSelection") ~typ:(returning void)
let exposedScrollViewRect self = msg_send ~self ~cmd:(selector "exposedScrollViewRect") ~typ:(returning CGRect.t)
let extendCurrentSelection x self = msg_send ~self ~cmd:(selector "extendCurrentSelection:") ~typ:(int @-> returning void) x
let fallbackDropPreviewForUninsertedContent x self = msg_send ~self ~cmd:(selector "fallbackDropPreviewForUninsertedContent:") ~typ:(id @-> returning id) x
let fileUploadPanelDidDismiss x self = msg_send ~self ~cmd:(selector "fileUploadPanelDidDismiss:") ~typ:(id @-> returning void) x
let firstRectForRange x self = msg_send ~self ~cmd:(selector "firstRectForRange:") ~typ:(id @-> returning CGRect.t) x
let fontForCaretSelection self = msg_send ~self ~cmd:(selector "fontForCaretSelection") ~typ:(returning id)
let forceLayout self = msg_send ~self ~cmd:(selector "forceLayout") ~typ:(returning void)
let formElement self = msg_send ~self ~cmd:(selector "formElement") ~typ:(returning id)
let forwardInvocation x self = msg_send ~self ~cmd:(selector "forwardInvocation:") ~typ:(id @-> returning void) x
let fragmentContainsRichContent x self = msg_send ~self ~cmd:(selector "fragmentContainsRichContent:") ~typ:(id @-> returning bool) x
let frameForDictationResultPlaceholder x self = msg_send ~self ~cmd:(selector "frameForDictationResultPlaceholder:") ~typ:(id @-> returning CGRect.t) x
let gestureRecognizer x ~canBePreventedByGestureRecognizer self = msg_send ~self ~cmd:(selector "gestureRecognizer:canBePreventedByGestureRecognizer:") ~typ:(id @-> id @-> returning bool) x canBePreventedByGestureRecognizer
let gestureRecognizer1 x ~canPreventGestureRecognizer self = msg_send ~self ~cmd:(selector "gestureRecognizer:canPreventGestureRecognizer:") ~typ:(id @-> id @-> returning bool) x canPreventGestureRecognizer
let gestureRecognizer2 x ~shouldReceiveTouch self = msg_send ~self ~cmd:(selector "gestureRecognizer:shouldReceiveTouch:") ~typ:(id @-> id @-> returning bool) x shouldReceiveTouch
let gestureRecognizer3 x ~shouldRecognizeSimultaneouslyWithGestureRecognizer self = msg_send ~self ~cmd:(selector "gestureRecognizer:shouldRecognizeSimultaneouslyWithGestureRecognizer:") ~typ:(id @-> id @-> returning bool) x shouldRecognizeSimultaneouslyWithGestureRecognizer
let gestureRecognizerShouldBegin x self = msg_send ~self ~cmd:(selector "gestureRecognizerShouldBegin:") ~typ:(id @-> returning bool) x
let getPasteboardChangeCount self = msg_send ~self ~cmd:(selector "getPasteboardChangeCount") ~typ:(returning llong)
let getPasteboardItemsCount self = msg_send ~self ~cmd:(selector "getPasteboardItemsCount") ~typ:(returning llong)
let handleKeyAppCommandForCurrentEvent self = msg_send ~self ~cmd:(selector "handleKeyAppCommandForCurrentEvent") ~typ:(returning bool)
let handleKeyTextCommandForCurrentEvent self = msg_send ~self ~cmd:(selector "handleKeyTextCommandForCurrentEvent") ~typ:(returning bool)
let handleKeyWebEvent x self = msg_send ~self ~cmd:(selector "handleKeyWebEvent:") ~typ:(id @-> returning void) x
let hasBodyElement self = msg_send ~self ~cmd:(selector "hasBodyElement") ~typ:(returning bool)
let hasContent self = msg_send ~self ~cmd:(selector "hasContent") ~typ:(returning bool)
let hasDrawnTiles self = msg_send ~self ~cmd:(selector "hasDrawnTiles") ~typ:(returning bool)
let hasEditableSelection self = msg_send ~self ~cmd:(selector "hasEditableSelection") ~typ:(returning bool)
let hasMarkedText self = msg_send ~self ~cmd:(selector "hasMarkedText") ~typ:(returning bool)
let hasPlugInSubviews self = msg_send ~self ~cmd:(selector "hasPlugInSubviews") ~typ:(returning bool)
let hasRangedSelection self = msg_send ~self ~cmd:(selector "hasRangedSelection") ~typ:(returning bool)
let hasRichlyEditableSelection self = msg_send ~self ~cmd:(selector "hasRichlyEditableSelection") ~typ:(returning bool)
let hasSelection self = msg_send ~self ~cmd:(selector "hasSelection") ~typ:(returning bool)
let hasText self = msg_send ~self ~cmd:(selector "hasText") ~typ:(returning bool)
let hideTapHighlight self = msg_send ~self ~cmd:(selector "hideTapHighlight") ~typ:(returning void)
let highlightApproximateNodeAndDisplayInfoSheet self = msg_send ~self ~cmd:(selector "highlightApproximateNodeAndDisplayInfoSheet") ~typ:(returning void)
let highlightApproximateNodeInverted x self = msg_send ~self ~cmd:(selector "highlightApproximateNodeInverted:") ~typ:(bool @-> returning void) x
let hostViewForSheet x self = msg_send ~self ~cmd:(selector "hostViewForSheet:") ~typ:(id @-> returning id) x
let implementationWebView self = msg_send ~self ~cmd:(selector "implementationWebView") ~typ:(returning id)
let inPopover self = msg_send ~self ~cmd:(selector "inPopover") ~typ:(returning bool)
let increaseSize x self = msg_send ~self ~cmd:(selector "increaseSize:") ~typ:(id @-> returning void) x
let initSimpleHTMLDocumentWithStyle x ~frame ~preferences ~groupName self = msg_send ~self ~cmd:(selector "initSimpleHTMLDocumentWithStyle:frame:preferences:groupName:") ~typ:(id @-> CGRect.t @-> id @-> id @-> returning id) x frame preferences groupName
let initWithFrame x self = msg_send ~self ~cmd:(selector "initWithFrame:") ~typ:(CGRect.t @-> returning id) x
let initWithWebView x ~frame self = msg_send ~self ~cmd:(selector "initWithWebView:frame:") ~typ:(id @-> CGRect.t @-> returning id) x frame
let initialDropSnapshotView self = msg_send ~self ~cmd:(selector "initialDropSnapshotView") ~typ:(returning id)
let initialPresentationRectInHostViewForSheet x self = msg_send ~self ~cmd:(selector "initialPresentationRectInHostViewForSheet:") ~typ:(id @-> returning CGRect.t) x
let initialScale self = msg_send ~self ~cmd:(selector "initialScale") ~typ:(returning float)
let inputDelegate self = msg_send ~self ~cmd:(selector "inputDelegate") ~typ:(returning id)
let insertDictationResult x ~withCorrectionIdentifier self = msg_send ~self ~cmd:(selector "insertDictationResult:withCorrectionIdentifier:") ~typ:(id @-> id @-> returning void) x withCorrectionIdentifier
let insertDictationResultPlaceholder self = msg_send ~self ~cmd:(selector "insertDictationResultPlaceholder") ~typ:(returning id)
let insertText x self = msg_send ~self ~cmd:(selector "insertText:") ~typ:(id @-> returning void) x
let insertTextPlaceholderWithSize x self = msg_send ~self ~cmd:(selector "insertTextPlaceholderWithSize:") ~typ:(CGSize.t @-> returning id) x
let insertionPointColor self = msg_send ~self ~cmd:(selector "insertionPointColor") ~typ:(returning id)
let installGestureRecognizers self = msg_send ~self ~cmd:(selector "installGestureRecognizers") ~typ:(returning void)
let interactionAssistant self = msg_send ~self ~cmd:(selector "interactionAssistant") ~typ:(returning id)
let interactionDelegate self = msg_send ~self ~cmd:(selector "interactionDelegate") ~typ:(returning id)
let interactionElement self = msg_send ~self ~cmd:(selector "interactionElement") ~typ:(returning id)
let interactionLocation self = msg_send ~self ~cmd:(selector "interactionLocation") ~typ:(returning CGPoint.t)
let isCaretInEmptyParagraph self = msg_send ~self ~cmd:(selector "isCaretInEmptyParagraph") ~typ:(returning bool)
let isClassicViewportMode self = msg_send ~self ~cmd:(selector "isClassicViewportMode") ~typ:(returning bool)
let isDoubleTapEnabled self = msg_send ~self ~cmd:(selector "isDoubleTapEnabled") ~typ:(returning bool)
let isEditable self = msg_send ~self ~cmd:(selector "isEditable") ~typ:(returning bool)
let isEditing self = msg_send ~self ~cmd:(selector "isEditing") ~typ:(returning bool)
let isEditingSingleLineElement self = msg_send ~self ~cmd:(selector "isEditingSingleLineElement") ~typ:(returning bool)
let isInInteraction self = msg_send ~self ~cmd:(selector "isInInteraction") ~typ:(returning bool)
let isInPrintMode self = msg_send ~self ~cmd:(selector "isInPrintMode") ~typ:(returning bool)
let isInsideRichlyEditableTextWidget self = msg_send ~self ~cmd:(selector "isInsideRichlyEditableTextWidget") ~typ:(returning bool)
let isPosition x ~atBoundary ~inDirection self = msg_send ~self ~cmd:(selector "isPosition:atBoundary:inDirection:") ~typ:(id @-> llong @-> llong @-> returning bool) x (LLong.of_int atBoundary) (LLong.of_int inDirection)
let isPosition' x ~withinTextUnit ~inDirection self = msg_send ~self ~cmd:(selector "isPosition:withinTextUnit:inDirection:") ~typ:(id @-> llong @-> llong @-> returning bool) x (LLong.of_int withinTextUnit) (LLong.of_int inDirection)
let isPreviewing self = msg_send ~self ~cmd:(selector "isPreviewing") ~typ:(returning bool)
let isShowingFullScreenPlugInUI self = msg_send ~self ~cmd:(selector "isShowingFullScreenPlugInUI") ~typ:(returning bool)
let isStandaloneEditableView self = msg_send ~self ~cmd:(selector "isStandaloneEditableView") ~typ:(returning bool)
let isWidgetEditingView self = msg_send ~self ~cmd:(selector "isWidgetEditingView") ~typ:(returning bool)
let keyboardInput x ~shouldInsertText ~isMarkedText self = msg_send ~self ~cmd:(selector "keyboardInput:shouldInsertText:isMarkedText:") ~typ:(id @-> id @-> bool @-> returning bool) x shouldInsertText isMarkedText
let keyboardInput' x ~shouldReplaceTextInRange ~replacementText self = msg_send ~self ~cmd:(selector "keyboardInput:shouldReplaceTextInRange:replacementText:") ~typ:(id @-> NSRange.t @-> id @-> returning bool) x shouldReplaceTextInRange replacementText
let keyboardInputChanged x self = msg_send ~self ~cmd:(selector "keyboardInputChanged:") ~typ:(id @-> returning bool) x
let keyboardInputChangedSelection x self = msg_send ~self ~cmd:(selector "keyboardInputChangedSelection:") ~typ:(id @-> returning void) x
let keyboardInputShouldDelete x self = msg_send ~self ~cmd:(selector "keyboardInputShouldDelete:") ~typ:(id @-> returning bool) x
let lastGlobalPosition self = msg_send ~self ~cmd:(selector "lastGlobalPosition") ~typ:(returning CGPoint.t)
let layoutSubviews self = msg_send ~self ~cmd:(selector "layoutSubviews") ~typ:(returning void)
let loadData x ~_MIMEType ~textEncodingName ~baseURL self = msg_send ~self ~cmd:(selector "loadData:MIMEType:textEncodingName:baseURL:") ~typ:(id @-> id @-> id @-> id @-> returning void) x _MIMEType textEncodingName baseURL
let loadHTMLString x ~baseURL self = msg_send ~self ~cmd:(selector "loadHTMLString:baseURL:") ~typ:(id @-> id @-> returning void) x baseURL
let loadRequest x self = msg_send ~self ~cmd:(selector "loadRequest:") ~typ:(id @-> returning void) x
let loadsSynchronously self = msg_send ~self ~cmd:(selector "loadsSynchronously") ~typ:(returning bool)
let makeTextWritingDirectionLeftToRight x self = msg_send ~self ~cmd:(selector "makeTextWritingDirectionLeftToRight:") ~typ:(id @-> returning void) x
let makeTextWritingDirectionNatural x self = msg_send ~self ~cmd:(selector "makeTextWritingDirectionNatural:") ~typ:(id @-> returning void) x
let makeTextWritingDirectionRightToLeft x self = msg_send ~self ~cmd:(selector "makeTextWritingDirectionRightToLeft:") ~typ:(id @-> returning void) x
let makeWKFirstResponder self = msg_send ~self ~cmd:(selector "makeWKFirstResponder") ~typ:(returning bool)
let markedTextRange self = msg_send ~self ~cmd:(selector "markedTextRange") ~typ:(returning id)
let markedTextStyle self = msg_send ~self ~cmd:(selector "markedTextStyle") ~typ:(returning id)
let maximumDoubleTapScale self = msg_send ~self ~cmd:(selector "maximumDoubleTapScale") ~typ:(returning double)
let maximumScale self = msg_send ~self ~cmd:(selector "maximumScale") ~typ:(returning float)
let mediaPlaybackAllowsAirPlay self = msg_send ~self ~cmd:(selector "mediaPlaybackAllowsAirPlay") ~typ:(returning bool)
let metadataDictionariesForDictationResults self = msg_send ~self ~cmd:(selector "metadataDictionariesForDictationResults") ~typ:(returning id)
let methodSignatureForSelector x self = msg_send ~self ~cmd:(selector "methodSignatureForSelector:") ~typ:(_SEL @-> returning id) x
let minimumScale self = msg_send ~self ~cmd:(selector "minimumScale") ~typ:(returning float)
let minimumScaleForMinimumSize x self = msg_send ~self ~cmd:(selector "minimumScaleForMinimumSize:") ~typ:(CGSize.t @-> returning float) x
let minimumScaleForSize x self = msg_send ~self ~cmd:(selector "minimumScaleForSize:") ~typ:(CGSize.t @-> returning double) x
let mouseEventsChangeSelection self = msg_send ~self ~cmd:(selector "mouseEventsChangeSelection") ~typ:(returning bool)
let needsScrollNotifications self = msg_send ~self ~cmd:(selector "needsScrollNotifications") ~typ:(returning bool)
let newMouseEvent x self = msg_send ~self ~cmd:(selector "newMouseEvent:") ~typ:(int @-> returning id) x
let newSnapshotWithRect x self = msg_send ~self ~cmd:(selector "newSnapshotWithRect:") ~typ:(CGRect.t @-> returning (ptr CGImage.t)) x
let offsetFromPosition x ~toPosition self = msg_send ~self ~cmd:(selector "offsetFromPosition:toPosition:") ~typ:(id @-> id @-> returning llong) x toPosition
let offsetInMarkedTextForSelection x self = msg_send ~self ~cmd:(selector "offsetInMarkedTextForSelection:") ~typ:(id @-> returning ullong) x
let paste x self = msg_send ~self ~cmd:(selector "paste:") ~typ:(id @-> returning void) x
let pasteAndMatchStyle x self = msg_send ~self ~cmd:(selector "pasteAndMatchStyle:") ~typ:(id @-> returning void) x
let performClick x self = msg_send ~self ~cmd:(selector "performClick:") ~typ:(id @-> returning void) x
let performInteractionSelector x ~afterDelay self = msg_send ~self ~cmd:(selector "performInteractionSelector:afterDelay:") ~typ:(_SEL @-> double @-> returning void) x afterDelay
let performTwoStepDrop x ~atDestination ~isMove self = msg_send ~self ~cmd:(selector "performTwoStepDrop:atDestination:isMove:") ~typ:(id @-> id @-> bool @-> returning bool) x atDestination isMove
let performsTwoStepPaste x self = msg_send ~self ~cmd:(selector "performsTwoStepPaste:") ~typ:(id @-> returning bool) x
let playsNicelyWithGestures self = msg_send ~self ~cmd:(selector "playsNicelyWithGestures") ~typ:(returning bool)
let positionAtStartOrEndOfWord x self = msg_send ~self ~cmd:(selector "positionAtStartOrEndOfWord:") ~typ:(id @-> returning id) x
let positionFromPosition x ~offset self = msg_send ~self ~cmd:(selector "positionFromPosition:offset:") ~typ:(id @-> llong @-> returning id) x (LLong.of_int offset)
let positionFromPosition1 x ~inDirection ~offset self = msg_send ~self ~cmd:(selector "positionFromPosition:inDirection:offset:") ~typ:(id @-> llong @-> llong @-> returning id) x (LLong.of_int inDirection) (LLong.of_int offset)
let positionFromPosition2 x ~toBoundary ~inDirection self = msg_send ~self ~cmd:(selector "positionFromPosition:toBoundary:inDirection:") ~typ:(id @-> llong @-> llong @-> returning id) x (LLong.of_int toBoundary) (LLong.of_int inDirection)
let positionWithinRange x ~farthestInDirection self = msg_send ~self ~cmd:(selector "positionWithinRange:farthestInDirection:") ~typ:(id @-> llong @-> returning id) x (LLong.of_int farthestInDirection)
let presentationRectInHostViewForSheet x self = msg_send ~self ~cmd:(selector "presentationRectInHostViewForSheet:") ~typ:(id @-> returning CGRect.t) x
let rangeByExtendingCurrentSelection x self = msg_send ~self ~cmd:(selector "rangeByExtendingCurrentSelection:") ~typ:(int @-> returning id) x
let rangeByMovingCurrentSelection x self = msg_send ~self ~cmd:(selector "rangeByMovingCurrentSelection:") ~typ:(int @-> returning id) x
let rangeEnclosingPosition x ~withGranularity ~inDirection self = msg_send ~self ~cmd:(selector "rangeEnclosingPosition:withGranularity:inDirection:") ~typ:(id @-> llong @-> llong @-> returning id) x (LLong.of_int withGranularity) (LLong.of_int inDirection)
let rangeOfEnclosingWord x self = msg_send ~self ~cmd:(selector "rangeOfEnclosingWord:") ~typ:(id @-> returning id) x
let rangeToRestoreAfterDictation self = msg_send ~self ~cmd:(selector "rangeToRestoreAfterDictation") ~typ:(returning id)
let readDataFromPasteboard x ~withIndex self = msg_send ~self ~cmd:(selector "readDataFromPasteboard:withIndex:") ~typ:(id @-> llong @-> returning id) x (LLong.of_int withIndex)
let rectOfInterestForPoint x self = msg_send ~self ~cmd:(selector "rectOfInterestForPoint:") ~typ:(CGPoint.t @-> returning CGRect.t) x
let rectsForNSRange x self = msg_send ~self ~cmd:(selector "rectsForNSRange:") ~typ:(NSRange.t @-> returning id) x
let redrawScaledDocument self = msg_send ~self ~cmd:(selector "redrawScaledDocument") ~typ:(returning void)
let releasePrintMode self = msg_send ~self ~cmd:(selector "releasePrintMode") ~typ:(returning void)
let removeDictationResultPlaceholder x ~willInsertResult self = msg_send ~self ~cmd:(selector "removeDictationResultPlaceholder:willInsertResult:") ~typ:(id @-> bool @-> returning void) x willInsertResult
let removeTextPlaceholder x self = msg_send ~self ~cmd:(selector "removeTextPlaceholder:") ~typ:(id @-> returning void) x
let renderTreeSize self = msg_send ~self ~cmd:(selector "renderTreeSize") ~typ:(returning ullong)
let renderTreeSizeThresholdForReset self = msg_send ~self ~cmd:(selector "renderTreeSizeThresholdForReset") ~typ:(returning ullong)
let replace x self = msg_send ~self ~cmd:(selector "replace:") ~typ:(id @-> returning void) x
let replaceCurrentWordWithText x self = msg_send ~self ~cmd:(selector "replaceCurrentWordWithText:") ~typ:(id @-> returning void) x
let replaceRange x ~withText self = msg_send ~self ~cmd:(selector "replaceRange:withText:") ~typ:(id @-> id @-> returning void) x withText
let replaceRangeWithTextWithoutClosingTyping x ~replacementText self = msg_send ~self ~cmd:(selector "replaceRangeWithTextWithoutClosingTyping:replacementText:") ~typ:(id @-> id @-> returning void) x replacementText
let replaceSelectionWithWebArchive x ~selectReplacement ~smartReplace self = msg_send ~self ~cmd:(selector "replaceSelectionWithWebArchive:selectReplacement:smartReplace:") ~typ:(id @-> bool @-> bool @-> returning void) x selectReplacement smartReplace
let requiresKeyEvents self = msg_send ~self ~cmd:(selector "requiresKeyEvents") ~typ:(returning bool)
let resetCurrentDragInformation self = msg_send ~self ~cmd:(selector "resetCurrentDragInformation") ~typ:(returning void)
let resetInteraction self = msg_send ~self ~cmd:(selector "resetInteraction") ~typ:(returning void)
let resetSelectionAssistant self = msg_send ~self ~cmd:(selector "resetSelectionAssistant") ~typ:(returning void)
let resetTilingAfterLoadComplete self = msg_send ~self ~cmd:(selector "resetTilingAfterLoadComplete") ~typ:(returning void)
let resignFirstResponder self = msg_send ~self ~cmd:(selector "resignFirstResponder") ~typ:(returning bool)
let revealedSelectionByScrollingWebFrame x self = msg_send ~self ~cmd:(selector "revealedSelectionByScrollingWebFrame:") ~typ:(id @-> returning void) x
let saveStateToCurrentHistoryItem self = msg_send ~self ~cmd:(selector "saveStateToCurrentHistoryItem") ~typ:(returning void)
let scrollSelectionToVisible x self = msg_send ~self ~cmd:(selector "scrollSelectionToVisible:") ~typ:(bool @-> returning void) x
let scrollViewWasRemoved self = msg_send ~self ~cmd:(selector "scrollViewWasRemoved") ~typ:(returning void)
let select x self = msg_send ~self ~cmd:(selector "select:") ~typ:(id @-> returning void) x
let selectAll self = msg_send ~self ~cmd:(selector "selectAll") ~typ:(returning void)
let selectAll' x self = msg_send ~self ~cmd:(selector "selectAll:") ~typ:(id @-> returning void) x
let selectWord self = msg_send ~self ~cmd:(selector "selectWord") ~typ:(returning void)
let selectedDOMRange self = msg_send ~self ~cmd:(selector "selectedDOMRange") ~typ:(returning id)
let selectedTextRange self = msg_send ~self ~cmd:(selector "selectedTextRange") ~typ:(returning id)
let selectionAffinity self = msg_send ~self ~cmd:(selector "selectionAffinity") ~typ:(returning llong)
let selectionAtDocumentStart self = msg_send ~self ~cmd:(selector "selectionAtDocumentStart") ~typ:(returning bool)
let selectionAtWordStart self = msg_send ~self ~cmd:(selector "selectionAtWordStart") ~typ:(returning bool)
let selectionBaseWritingDirection self = msg_send ~self ~cmd:(selector "selectionBaseWritingDirection") ~typ:(returning llong)
let selectionChanged self = msg_send ~self ~cmd:(selector "selectionChanged") ~typ:(returning void)
let selectionChanged' x self = msg_send ~self ~cmd:(selector "selectionChanged:") ~typ:(id @-> returning void) x
let selectionGranularity self = msg_send ~self ~cmd:(selector "selectionGranularity") ~typ:(returning llong)
let selectionRange self = msg_send ~self ~cmd:(selector "selectionRange") ~typ:(returning NSRange.t)
let selectionRects self = msg_send ~self ~cmd:(selector "selectionRects") ~typ:(returning id)
let selectionRectsForDOMRange x self = msg_send ~self ~cmd:(selector "selectionRectsForDOMRange:") ~typ:(id @-> returning id) x
let selectionRectsForRange x self = msg_send ~self ~cmd:(selector "selectionRectsForRange:") ~typ:(id @-> returning id) x
let selectionState self = msg_send ~self ~cmd:(selector "selectionState") ~typ:(returning int)
let selectionView self = msg_send ~self ~cmd:(selector "selectionView") ~typ:(returning id)
let sendOrientationEventForOrientation x self = msg_send ~self ~cmd:(selector "sendOrientationEventForOrientation:") ~typ:(llong @-> returning void) (LLong.of_int x)
let sendScrollEventIfNecessary self = msg_send ~self ~cmd:(selector "sendScrollEventIfNecessary") ~typ:(returning void)
let sendScrollEventIfNecessaryWasUserScroll x self = msg_send ~self ~cmd:(selector "sendScrollEventIfNecessaryWasUserScroll:") ~typ:(bool @-> returning void) x
let sendScrollWheelEvents self = msg_send ~self ~cmd:(selector "sendScrollWheelEvents") ~typ:(returning void)
let setAllowsDataDetectorsSheet x self = msg_send ~self ~cmd:(selector "setAllowsDataDetectorsSheet:") ~typ:(bool @-> returning void) x
let setAllowsImageSheet x self = msg_send ~self ~cmd:(selector "setAllowsImageSheet:") ~typ:(bool @-> returning void) x
let setAllowsLinkSheet x self = msg_send ~self ~cmd:(selector "setAllowsLinkSheet:") ~typ:(bool @-> returning void) x
let setAllowsShrinkToFit x ~forDocumentTypes self = msg_send ~self ~cmd:(selector "setAllowsShrinkToFit:forDocumentTypes:") ~typ:(bool @-> int @-> returning void) x forDocumentTypes
let setAllowsUserScaling x ~forDocumentTypes self = msg_send ~self ~cmd:(selector "setAllowsUserScaling:forDocumentTypes:") ~typ:(bool @-> int @-> returning void) x forDocumentTypes
let setAlwaysConstrainsScale x self = msg_send ~self ~cmd:(selector "setAlwaysConstrainsScale:") ~typ:(bool @-> returning void) x
let setAutoresizes x self = msg_send ~self ~cmd:(selector "setAutoresizes:") ~typ:(bool @-> returning void) x
let setAutoscrollContentOffset x self = msg_send ~self ~cmd:(selector "setAutoscrollContentOffset:") ~typ:(CGPoint.t @-> returning void) x
let setAvoidsUnsafeArea x ~forDocumentTypes self = msg_send ~self ~cmd:(selector "setAvoidsUnsafeArea:forDocumentTypes:") ~typ:(bool @-> int @-> returning void) x forDocumentTypes
let setBaseWritingDirection x self = msg_send ~self ~cmd:(selector "setBaseWritingDirection:") ~typ:(llong @-> returning void) (LLong.of_int x)
let setBaseWritingDirection' x ~forRange self = msg_send ~self ~cmd:(selector "setBaseWritingDirection:forRange:") ~typ:(llong @-> id @-> returning void) (LLong.of_int x) forRange
let setBecomesEditableWithGestures x self = msg_send ~self ~cmd:(selector "setBecomesEditableWithGestures:") ~typ:(bool @-> returning void) x
let setBottomBufferHeight x self = msg_send ~self ~cmd:(selector "setBottomBufferHeight:") ~typ:(double @-> returning void) x
let setCaretChangeListener x self = msg_send ~self ~cmd:(selector "setCaretChangeListener:") ~typ:(id @-> returning void) x
let setCaretInsets x self = msg_send ~self ~cmd:(selector "setCaretInsets:") ~typ:(UIEdgeInsets.t @-> returning void) x
let setContinuousSpellCheckingEnabled x self = msg_send ~self ~cmd:(selector "setContinuousSpellCheckingEnabled:") ~typ:(bool @-> returning void) x
let setCurrentDragCaretRect x self = msg_send ~self ~cmd:(selector "setCurrentDragCaretRect:") ~typ:(CGRect.t @-> returning void) x
let setCurrentDragSourceAction x self = msg_send ~self ~cmd:(selector "setCurrentDragSourceAction:") ~typ:(ullong @-> returning void) (ULLong.of_int x)
let setDataDetectorTypes x self = msg_send ~self ~cmd:(selector "setDataDetectorTypes:") ~typ:(ullong @-> returning void) (ULLong.of_int x)
let setDelegate x self = msg_send ~self ~cmd:(selector "setDelegate:") ~typ:(id @-> returning void) x
let setDetectsPhoneNumbers x self = msg_send ~self ~cmd:(selector "setDetectsPhoneNumbers:") ~typ:(bool @-> returning void) x
let setDoubleTapEnabled x self = msg_send ~self ~cmd:(selector "setDoubleTapEnabled:") ~typ:(bool @-> returning void) x
let setDragInteraction x self = msg_send ~self ~cmd:(selector "setDragInteraction:") ~typ:(id @-> returning void) x
let setDragInteractionEnabled x self = msg_send ~self ~cmd:(selector "setDragInteractionEnabled:") ~typ:(bool @-> returning void) x
let setDraggedLinkTitle x self = msg_send ~self ~cmd:(selector "setDraggedLinkTitle:") ~typ:(id @-> returning void) x
let setDraggedLinkURL x self = msg_send ~self ~cmd:(selector "setDraggedLinkURL:") ~typ:(id @-> returning void) x
let setDrawsBackground x self = msg_send ~self ~cmd:(selector "setDrawsBackground:") ~typ:(bool @-> returning void) x
let setDropInteraction x self = msg_send ~self ~cmd:(selector "setDropInteraction:") ~typ:(id @-> returning void) x
let setExposedScrollViewRect x self = msg_send ~self ~cmd:(selector "setExposedScrollViewRect:") ~typ:(CGRect.t @-> returning void) x
let setFrame x self = msg_send ~self ~cmd:(selector "setFrame:") ~typ:(CGRect.t @-> returning void) x
let setIgnoresFocusingMouse x self = msg_send ~self ~cmd:(selector "setIgnoresFocusingMouse:") ~typ:(bool @-> returning void) x
let setIgnoresKeyEvents x self = msg_send ~self ~cmd:(selector "setIgnoresKeyEvents:") ~typ:(bool @-> returning void) x
let setIgnoresViewportOverflowWhenAutoresizing x self = msg_send ~self ~cmd:(selector "setIgnoresViewportOverflowWhenAutoresizing:") ~typ:(bool @-> returning void) x
let setInitialDropSnapshotView x self = msg_send ~self ~cmd:(selector "setInitialDropSnapshotView:") ~typ:(id @-> returning void) x
let setInitialScale x ~forDocumentTypes self = msg_send ~self ~cmd:(selector "setInitialScale:forDocumentTypes:") ~typ:(float @-> int @-> returning void) x forDocumentTypes
let setInputDelegate x self = msg_send ~self ~cmd:(selector "setInputDelegate:") ~typ:(id @-> returning void) x
let setInteractionAssistantGestureRecognizers self = msg_send ~self ~cmd:(selector "setInteractionAssistantGestureRecognizers") ~typ:(returning void)
let setInteractionDelegate x self = msg_send ~self ~cmd:(selector "setInteractionDelegate:") ~typ:(id @-> returning void) x
let setIsStandaloneEditableView x self = msg_send ~self ~cmd:(selector "setIsStandaloneEditableView:") ~typ:(bool @-> returning void) x
let setIsWidgetEditingView x self = msg_send ~self ~cmd:(selector "setIsWidgetEditingView:") ~typ:(bool @-> returning void) x
let setLastGlobalPosition x self = msg_send ~self ~cmd:(selector "setLastGlobalPosition:") ~typ:(CGPoint.t @-> returning void) x
let setLoadsSynchronously x self = msg_send ~self ~cmd:(selector "setLoadsSynchronously:") ~typ:(bool @-> returning void) x
let setMarkedText x ~selectedRange self = msg_send ~self ~cmd:(selector "setMarkedText:selectedRange:") ~typ:(id @-> NSRange.t @-> returning void) x selectedRange
let setMarkedTextStyle x self = msg_send ~self ~cmd:(selector "setMarkedTextStyle:") ~typ:(id @-> returning void) x
let setMaximumScale x ~forDocumentTypes self = msg_send ~self ~cmd:(selector "setMaximumScale:forDocumentTypes:") ~typ:(float @-> int @-> returning void) x forDocumentTypes
let setMediaPlaybackAllowsAirPlay x self = msg_send ~self ~cmd:(selector "setMediaPlaybackAllowsAirPlay:") ~typ:(bool @-> returning void) x
let setMinimumScale x ~forDocumentTypes self = msg_send ~self ~cmd:(selector "setMinimumScale:forDocumentTypes:") ~typ:(float @-> int @-> returning void) x forDocumentTypes
let setMinimumSize x self = msg_send ~self ~cmd:(selector "setMinimumSize:") ~typ:(CGSize.t @-> returning void) x
let setMinimumSize' x ~updateCurrentViewportConfigurationSize self = msg_send ~self ~cmd:(selector "setMinimumSize:updateCurrentViewportConfigurationSize:") ~typ:(CGSize.t @-> bool @-> returning void) x updateCurrentViewportConfigurationSize
let setOpaque x self = msg_send ~self ~cmd:(selector "setOpaque:") ~typ:(bool @-> returning void) x
let setPaused x self = msg_send ~self ~cmd:(selector "setPaused:") ~typ:(bool @-> returning void) x
let setPaused' x ~withEvents self = msg_send ~self ~cmd:(selector "setPaused:withEvents:") ~typ:(bool @-> bool @-> returning void) x withEvents
let setRangeToRestoreAfterDictation x self = msg_send ~self ~cmd:(selector "setRangeToRestoreAfterDictation:") ~typ:(id @-> returning void) x
let setRangedSelectionBaseToCurrentSelection self = msg_send ~self ~cmd:(selector "setRangedSelectionBaseToCurrentSelection") ~typ:(returning void)
let setRangedSelectionBaseToCurrentSelectionEnd self = msg_send ~self ~cmd:(selector "setRangedSelectionBaseToCurrentSelectionEnd") ~typ:(returning void)
let setRangedSelectionBaseToCurrentSelectionStart self = msg_send ~self ~cmd:(selector "setRangedSelectionBaseToCurrentSelectionStart") ~typ:(returning void)
let setRangedSelectionExtentPoint x ~baseIsStart self = msg_send ~self ~cmd:(selector "setRangedSelectionExtentPoint:baseIsStart:") ~typ:(CGPoint.t @-> bool @-> returning bool) x baseIsStart
let setRangedSelectionExtentPoint' x ~baseIsStart ~allowFlipping self = msg_send ~self ~cmd:(selector "setRangedSelectionExtentPoint:baseIsStart:allowFlipping:") ~typ:(CGPoint.t @-> bool @-> bool @-> returning void) x baseIsStart allowFlipping
let setRangedSelectionInitialExtentToCurrentSelectionEnd self = msg_send ~self ~cmd:(selector "setRangedSelectionInitialExtentToCurrentSelectionEnd") ~typ:(returning void)
let setRangedSelectionInitialExtentToCurrentSelectionStart self = msg_send ~self ~cmd:(selector "setRangedSelectionInitialExtentToCurrentSelectionStart") ~typ:(returning void)
let setRangedSelectionWithExtentPoint x self = msg_send ~self ~cmd:(selector "setRangedSelectionWithExtentPoint:") ~typ:(CGPoint.t @-> returning void) x
let setRenderTreeSizeThresholdForReset x self = msg_send ~self ~cmd:(selector "setRenderTreeSizeThresholdForReset:") ~typ:(ullong @-> returning void) (ULLong.of_int x)
let setSelectedDOMRange x ~affinity self = msg_send ~self ~cmd:(selector "setSelectedDOMRange:affinity:") ~typ:(id @-> ullong @-> returning void) x (ULLong.of_int affinity)
let setSelectedDOMRange' x ~affinityDownstream self = msg_send ~self ~cmd:(selector "setSelectedDOMRange:affinityDownstream:") ~typ:(id @-> bool @-> returning void) x affinityDownstream
let setSelectedTextRange x self = msg_send ~self ~cmd:(selector "setSelectedTextRange:") ~typ:(id @-> returning void) x
let setSelectedTextRange' x ~withAffinityDownstream self = msg_send ~self ~cmd:(selector "setSelectedTextRange:withAffinityDownstream:") ~typ:(id @-> bool @-> returning void) x withAffinityDownstream
let setSelectionAffinity x self = msg_send ~self ~cmd:(selector "setSelectionAffinity:") ~typ:(llong @-> returning void) (LLong.of_int x)
let setSelectionGranularity x self = msg_send ~self ~cmd:(selector "setSelectionGranularity:") ~typ:(llong @-> returning void) (LLong.of_int x)
let setSelectionToEnd self = msg_send ~self ~cmd:(selector "setSelectionToEnd") ~typ:(returning void)
let setSelectionToStart self = msg_send ~self ~cmd:(selector "setSelectionToStart") ~typ:(returning void)
let setSelectionWithFirstPoint x ~secondPoint self = msg_send ~self ~cmd:(selector "setSelectionWithFirstPoint:secondPoint:") ~typ:(CGPoint.t @-> CGPoint.t @-> returning void) x secondPoint
let setSelectionWithPoint x self = msg_send ~self ~cmd:(selector "setSelectionWithPoint:") ~typ:(CGPoint.t @-> returning void) x
let setShouldAutoscroll x self = msg_send ~self ~cmd:(selector "setShouldAutoscroll:") ~typ:(bool @-> returning void) x
let setShouldIgnoreCustomViewport x self = msg_send ~self ~cmd:(selector "setShouldIgnoreCustomViewport:") ~typ:(bool @-> returning void) x
let setShouldOnlyRecognizeGesturesOnActiveElements x self = msg_send ~self ~cmd:(selector "setShouldOnlyRecognizeGesturesOnActiveElements:") ~typ:(bool @-> returning void) x
let setSizeUpdatesSuspended x self = msg_send ~self ~cmd:(selector "setSizeUpdatesSuspended:") ~typ:(bool @-> returning void) x
let setSmoothsFonts x self = msg_send ~self ~cmd:(selector "setSmoothsFonts:") ~typ:(bool @-> returning void) x
let setStandaloneEditingElement x self = msg_send ~self ~cmd:(selector "setStandaloneEditingElement:") ~typ:(id @-> returning void) x
let setSuppressesIncrementalRendering x self = msg_send ~self ~cmd:(selector "setSuppressesIncrementalRendering:") ~typ:(bool @-> returning void) x
let setText x self = msg_send ~self ~cmd:(selector "setText:") ~typ:(id @-> returning void) x
let setTileUpdatesDisabled x self = msg_send ~self ~cmd:(selector "setTileUpdatesDisabled:") ~typ:(bool @-> returning void) x
let setTilingArea x self = msg_send ~self ~cmd:(selector "setTilingArea:") ~typ:(int @-> returning void) x
let setUpdatesScrollView x self = msg_send ~self ~cmd:(selector "setUpdatesScrollView:") ~typ:(bool @-> returning void) x
let setUserStyleSheet x self = msg_send ~self ~cmd:(selector "setUserStyleSheet:") ~typ:(id @-> returning void) x
let setViewportSize x ~forDocumentTypes self = msg_send ~self ~cmd:(selector "setViewportSize:forDocumentTypes:") ~typ:(CGSize.t @-> int @-> returning void) x forDocumentTypes
let setWebDraggingDelegate x self = msg_send ~self ~cmd:(selector "setWebDraggingDelegate:") ~typ:(id @-> returning void) x
let shouldAutoscroll self = msg_send ~self ~cmd:(selector "shouldAutoscroll") ~typ:(returning bool)
let shouldIgnoreCustomViewport self = msg_send ~self ~cmd:(selector "shouldIgnoreCustomViewport") ~typ:(returning bool)
let shouldOnlyRecognizeGesturesOnActiveElements self = msg_send ~self ~cmd:(selector "shouldOnlyRecognizeGesturesOnActiveElements") ~typ:(returning bool)
let shouldSelectionAssistantReceiveDoubleTapAtPoint x ~forScale self = msg_send ~self ~cmd:(selector "shouldSelectionAssistantReceiveDoubleTapAtPoint:forScale:") ~typ:(CGPoint.t @-> double @-> returning bool) x forScale
let shouldSuppressPasswordEcho self = msg_send ~self ~cmd:(selector "shouldSuppressPasswordEcho") ~typ:(returning bool)
let showPlaybackTargetPicker x ~fromRect self = msg_send ~self ~cmd:(selector "showPlaybackTargetPicker:fromRect:") ~typ:(bool @-> CGRect.t @-> returning void) x fromRect
let sizeUpdatesSuspended self = msg_send ~self ~cmd:(selector "sizeUpdatesSuspended") ~typ:(returning bool)
let smartExtendRangedSelection x self = msg_send ~self ~cmd:(selector "smartExtendRangedSelection:") ~typ:(int @-> returning void) x
let standaloneEditingElement self = msg_send ~self ~cmd:(selector "standaloneEditingElement") ~typ:(returning id)
let startActionSheet self = msg_send ~self ~cmd:(selector "startActionSheet") ~typ:(returning bool)
let startAutoscroll x self = msg_send ~self ~cmd:(selector "startAutoscroll:") ~typ:(CGPoint.t @-> returning void) x
let startInteractionWithLocation x self = msg_send ~self ~cmd:(selector "startInteractionWithLocation:") ~typ:(CGPoint.t @-> returning void) x
let stopLoading x self = msg_send ~self ~cmd:(selector "stopLoading:") ~typ:(id @-> returning void) x
let subviews self = msg_send ~self ~cmd:(selector "subviews") ~typ:(returning id)
let superviewForSheet self = msg_send ~self ~cmd:(selector "superviewForSheet") ~typ:(returning id)
let supportedPasteboardTypesForCurrentSelection self = msg_send ~self ~cmd:(selector "supportedPasteboardTypesForCurrentSelection") ~typ:(returning id)
let supportsTwoFingerScrollingAtTouchLocation x ~andLocation self = msg_send ~self ~cmd:(selector "supportsTwoFingerScrollingAtTouchLocation:andLocation:") ~typ:(CGPoint.t @-> CGPoint.t @-> returning bool) x andLocation
let suppressesIncrementalRendering self = msg_send ~self ~cmd:(selector "suppressesIncrementalRendering") ~typ:(returning bool)
let takeTraitsFrom x self = msg_send ~self ~cmd:(selector "takeTraitsFrom:") ~typ:(id @-> returning void) x
let tapInteractionWithLocation x self = msg_send ~self ~cmd:(selector "tapInteractionWithLocation:") ~typ:(CGPoint.t @-> returning void) x
let targetedDragPreviewFromCurrentTextIndicatorData self = msg_send ~self ~cmd:(selector "targetedDragPreviewFromCurrentTextIndicatorData") ~typ:(returning id)
let text self = msg_send ~self ~cmd:(selector "text") ~typ:(returning id)
let textColorForCaretSelection self = msg_send ~self ~cmd:(selector "textColorForCaretSelection") ~typ:(returning id)
let textFormElement self = msg_send ~self ~cmd:(selector "textFormElement") ~typ:(returning id)
let textInDOMRange x self = msg_send ~self ~cmd:(selector "textInDOMRange:") ~typ:(id @-> returning id) x
let textInRange x self = msg_send ~self ~cmd:(selector "textInRange:") ~typ:(id @-> returning id) x
let textInputTraits self = msg_send ~self ~cmd:(selector "textInputTraits") ~typ:(returning id)
let textRangeFromPosition x ~toPosition self = msg_send ~self ~cmd:(selector "textRangeFromPosition:toPosition:") ~typ:(id @-> id @-> returning id) x toPosition
let textStylingAtPosition x ~inDirection self = msg_send ~self ~cmd:(selector "textStylingAtPosition:inDirection:") ~typ:(id @-> llong @-> returning id) x (LLong.of_int inDirection)
let toggleBaseWritingDirection self = msg_send ~self ~cmd:(selector "toggleBaseWritingDirection") ~typ:(returning void)
let toggleBoldface x self = msg_send ~self ~cmd:(selector "toggleBoldface:") ~typ:(id @-> returning void) x
let toggleItalics x self = msg_send ~self ~cmd:(selector "toggleItalics:") ~typ:(id @-> returning void) x
let toggleUnderline x self = msg_send ~self ~cmd:(selector "toggleUnderline:") ~typ:(id @-> returning void) x
let tokenizer self = msg_send ~self ~cmd:(selector "tokenizer") ~typ:(returning id)
let undoManager self = msg_send ~self ~cmd:(selector "undoManager") ~typ:(returning id)
let undoManagerForWebView x self = msg_send ~self ~cmd:(selector "undoManagerForWebView:") ~typ:(id @-> returning id) x
let unmarkText self = msg_send ~self ~cmd:(selector "unmarkText") ~typ:(returning void)
let updateDragCaretIfPossible self = msg_send ~self ~cmd:(selector "updateDragCaretIfPossible") ~typ:(returning void)
let updateFloatingCursorAtPoint x self = msg_send ~self ~cmd:(selector "updateFloatingCursorAtPoint:") ~typ:(CGPoint.t @-> returning void) x
let updateFloatingCursorAtPoint' x ~velocity self = msg_send ~self ~cmd:(selector "updateFloatingCursorAtPoint:velocity:") ~typ:(CGPoint.t @-> CGPoint.t @-> returning void) x velocity
let updateInteractionElements self = msg_send ~self ~cmd:(selector "updateInteractionElements") ~typ:(returning void)
let updateKeyboardStateOnResponderChanges self = msg_send ~self ~cmd:(selector "updateKeyboardStateOnResponderChanges") ~typ:(returning bool)
let updateSelection self = msg_send ~self ~cmd:(selector "updateSelection") ~typ:(returning void)
let updatesScrollView self = msg_send ~self ~cmd:(selector "updatesScrollView") ~typ:(returning bool)
let useSelectionAssistantWithMode x self = msg_send ~self ~cmd:(selector "useSelectionAssistantWithMode:") ~typ:(int @-> returning void) x
let validateInteractionWithLocation x self = msg_send ~self ~cmd:(selector "validateInteractionWithLocation:") ~typ:(CGPoint.t @-> returning void) x
let viewportHandler x ~didChangeAvoidsUnsafeArea self = msg_send ~self ~cmd:(selector "viewportHandler:didChangeAvoidsUnsafeArea:") ~typ:(id @-> bool @-> returning void) x didChangeAvoidsUnsafeArea
let viewportHandler' x ~didChangeViewportSize self = msg_send ~self ~cmd:(selector "viewportHandler:didChangeViewportSize:") ~typ:(id @-> CGSize.t @-> returning void) x didChangeViewportSize
let viewportHandlerDidChangeScales x self = msg_send ~self ~cmd:(selector "viewportHandlerDidChangeScales:") ~typ:(id @-> returning void) x
let visibleBounds self = msg_send ~self ~cmd:(selector "visibleBounds") ~typ:(returning CGRect.t)
let visibleContentFrame self = msg_send ~self ~cmd:(selector "visibleContentFrame") ~typ:(returning CGRect.t)
let visibleContentRect self = msg_send ~self ~cmd:(selector "visibleContentRect") ~typ:(returning CGRect.t)
let visibleFrame self = msg_send ~self ~cmd:(selector "visibleFrame") ~typ:(returning CGRect.t)
let wantsMinimalUI self = msg_send ~self ~cmd:(selector "wantsMinimalUI") ~typ:(returning bool)
let webDraggingDelegate self = msg_send ~self ~cmd:(selector "webDraggingDelegate") ~typ:(returning id)
let webThreadWebViewDidLayout x ~byScrolling self = msg_send ~self ~cmd:(selector "webThreadWebViewDidLayout:byScrolling:") ~typ:(id @-> bool @-> returning void) x byScrolling
let webView self = msg_send ~self ~cmd:(selector "webView") ~typ:(returning id)
let webView1 x ~didChangeLocationWithinPageForFrame self = msg_send ~self ~cmd:(selector "webView:didChangeLocationWithinPageForFrame:") ~typ:(id @-> id @-> returning void) x didChangeLocationWithinPageForFrame
let webView2 x ~didCommitLoadForFrame self = msg_send ~self ~cmd:(selector "webView:didCommitLoadForFrame:") ~typ:(id @-> id @-> returning void) x didCommitLoadForFrame
let webView3 x ~didFinishLoadForFrame self = msg_send ~self ~cmd:(selector "webView:didFinishLoadForFrame:") ~typ:(id @-> id @-> returning void) x didFinishLoadForFrame
let webView4 x ~didFirstVisuallyNonEmptyLayoutInFrame self = msg_send ~self ~cmd:(selector "webView:didFirstVisuallyNonEmptyLayoutInFrame:") ~typ:(id @-> id @-> returning void) x didFirstVisuallyNonEmptyLayoutInFrame
let webView5 x ~didHideFullScreenForPlugInView self = msg_send ~self ~cmd:(selector "webView:didHideFullScreenForPlugInView:") ~typ:(id @-> id @-> returning void) x didHideFullScreenForPlugInView
let webView6 x ~didReceiveViewportArguments self = msg_send ~self ~cmd:(selector "webView:didReceiveViewportArguments:") ~typ:(id @-> id @-> returning void) x didReceiveViewportArguments
let webView7 x ~willAddPlugInView self = msg_send ~self ~cmd:(selector "webView:willAddPlugInView:") ~typ:(id @-> id @-> returning void) x willAddPlugInView
let webView8 x ~willShowFullScreenForPlugInView self = msg_send ~self ~cmd:(selector "webView:willShowFullScreenForPlugInView:") ~typ:(id @-> id @-> returning void) x willShowFullScreenForPlugInView
let webView9 x ~didFailLoadWithError ~forFrame self = msg_send ~self ~cmd:(selector "webView:didFailLoadWithError:forFrame:") ~typ:(id @-> id @-> id @-> returning void) x didFailLoadWithError forFrame
let webView10 x ~didObserveDeferredContentChange ~forFrame self = msg_send ~self ~cmd:(selector "webView:didObserveDeferredContentChange:forFrame:") ~typ:(id @-> int @-> id @-> returning void) x didObserveDeferredContentChange forFrame
let webView11 x ~needsScrollNotifications ~forFrame self = msg_send ~self ~cmd:(selector "webView:needsScrollNotifications:forFrame:") ~typ:(id @-> id @-> id @-> returning void) x needsScrollNotifications forFrame
let webView12 x ~plugInViewWithArguments ~fromPlugInPackage self = msg_send ~self ~cmd:(selector "webView:plugInViewWithArguments:fromPlugInPackage:") ~typ:(id @-> id @-> id @-> returning id) x plugInViewWithArguments fromPlugInPackage
let webView13 x ~runOpenPanelForFileButtonWithResultListener ~configuration self = msg_send ~self ~cmd:(selector "webView:runOpenPanelForFileButtonWithResultListener:configuration:") ~typ:(id @-> id @-> id @-> returning void) x runOpenPanelForFileButtonWithResultListener configuration
let webView14 x ~saveStateToHistoryItem ~forFrame self = msg_send ~self ~cmd:(selector "webView:saveStateToHistoryItem:forFrame:") ~typ:(id @-> id @-> id @-> returning void) x saveStateToHistoryItem forFrame
let webView15 x ~shouldScrollToPoint ~forFrame self = msg_send ~self ~cmd:(selector "webView:shouldScrollToPoint:forFrame:") ~typ:(id @-> CGPoint.t @-> id @-> returning bool) x shouldScrollToPoint forFrame
let webView16 x ~restoreStateFromHistoryItem ~forFrame ~force self = msg_send ~self ~cmd:(selector "webView:restoreStateFromHistoryItem:forFrame:force:") ~typ:(id @-> id @-> id @-> bool @-> returning void) x restoreStateFromHistoryItem forFrame force
let webViewDidCommitCompositingLayerChanges x self = msg_send ~self ~cmd:(selector "webViewDidCommitCompositingLayerChanges:") ~typ:(id @-> returning void) x
let webViewDidDrawTiles x self = msg_send ~self ~cmd:(selector "webViewDidDrawTiles:") ~typ:(id @-> returning void) x
let webViewDidEndOverflowScroll x self = msg_send ~self ~cmd:(selector "webViewDidEndOverflowScroll:") ~typ:(id @-> returning void) x
let webViewDidPreventDefaultForEvent x self = msg_send ~self ~cmd:(selector "webViewDidPreventDefaultForEvent:") ~typ:(id @-> returning void) x
let webViewDidReceiveMobileDocType x self = msg_send ~self ~cmd:(selector "webViewDidReceiveMobileDocType:") ~typ:(id @-> returning void) x
let webViewDidRestoreFromPageCache x self = msg_send ~self ~cmd:(selector "webViewDidRestoreFromPageCache:") ~typ:(id @-> returning void) x
let webViewDidStartOverflowScroll x self = msg_send ~self ~cmd:(selector "webViewDidStartOverflowScroll:") ~typ:(id @-> returning void) x
let webViewFrameForUIFrame x self = msg_send ~self ~cmd:(selector "webViewFrameForUIFrame:") ~typ:(CGRect.t @-> returning CGRect.t) x
let webVisiblePositionForPoint x self = msg_send ~self ~cmd:(selector "webVisiblePositionForPoint:") ~typ:(CGPoint.t @-> returning id) x
let willInteractWithLocation x self = msg_send ~self ~cmd:(selector "willInteractWithLocation:") ~typ:(CGPoint.t @-> returning bool) x
let willMoveToSuperview x self = msg_send ~self ~cmd:(selector "willMoveToSuperview:") ~typ:(id @-> returning void) x
let willMoveToWindow x self = msg_send ~self ~cmd:(selector "willMoveToWindow:") ~typ:(id @-> returning void) x
let willRotateInteractionSheet self = msg_send ~self ~cmd:(selector "willRotateInteractionSheet") ~typ:(returning void)
let willStartScroll self = msg_send ~self ~cmd:(selector "willStartScroll") ~typ:(returning void)
let willStartScrollToTop self = msg_send ~self ~cmd:(selector "willStartScrollToTop") ~typ:(returning void)
let willStartZoom self = msg_send ~self ~cmd:(selector "willStartZoom") ~typ:(returning void)
let willZoomToLocation x ~atScale ~forDuration self = msg_send ~self ~cmd:(selector "willZoomToLocation:atScale:forDuration:") ~typ:(CGPoint.t @-> double @-> double @-> returning void) x atScale forDuration
let willZoomToMinimumScale self = msg_send ~self ~cmd:(selector "willZoomToMinimumScale") ~typ:(returning void)
let wordAtPoint x self = msg_send ~self ~cmd:(selector "wordAtPoint:") ~typ:(CGPoint.t @-> returning id) x
let wordOffsetInRange x self = msg_send ~self ~cmd:(selector "wordOffsetInRange:") ~typ:(id @-> returning int) x
let writeDataToPasteboard x self = msg_send ~self ~cmd:(selector "writeDataToPasteboard:") ~typ:(id @-> returning void) x
let zoomedDocumentScale self = msg_send ~self ~cmd:(selector "zoomedDocumentScale") ~typ:(returning double)