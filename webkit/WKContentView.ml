(* auto-generated, do not modify *)

open Runtime
open Objc

[@@@ocaml.warning "-33"]
open Foundation

let _class_ = get_class "WKContentView"

let accessibilityRetrieveSpeakSelectionContent self = msg_send ~self ~cmd:(selector "accessibilityRetrieveSpeakSelectionContent") ~typ:(returning (void))
let accessoryAutoFill self = msg_send ~self ~cmd:(selector "accessoryAutoFill") ~typ:(returning (void))
let accessoryClear self = msg_send ~self ~cmd:(selector "accessoryClear") ~typ:(returning (void))
let accessoryDone self = msg_send ~self ~cmd:(selector "accessoryDone") ~typ:(returning (void))
let accessoryOpen self = msg_send ~self ~cmd:(selector "accessoryOpen") ~typ:(returning (void))
let accessoryTab x self = msg_send ~self ~cmd:(selector "accessoryTab:") ~typ:(bool @-> returning (void)) x
let actionSheetAssistant x ~openElementAtLocation self = msg_send ~self ~cmd:(selector "actionSheetAssistant:openElementAtLocation:") ~typ:(id @-> CGPoint.t @-> returning (void)) x openElementAtLocation
let actionSheetAssistant1 x ~performAction self = msg_send ~self ~cmd:(selector "actionSheetAssistant:performAction:") ~typ:(id @-> bool @-> returning (void)) x performAction
let actionSheetAssistant2 x ~showCustomSheetForElement self = msg_send ~self ~cmd:(selector "actionSheetAssistant:showCustomSheetForElement:") ~typ:(id @-> id @-> returning (bool)) x showCustomSheetForElement
let actionSheetAssistant3 x ~willStartInteractionWithElement self = msg_send ~self ~cmd:(selector "actionSheetAssistant:willStartInteractionWithElement:") ~typ:(id @-> id @-> returning (void)) x willStartInteractionWithElement
let actionSheetAssistant4 x ~getAlternateURLForImage ~completion self = msg_send ~self ~cmd:(selector "actionSheetAssistant:getAlternateURLForImage:completion:") ~typ:(id @-> id @-> ptr void @-> returning (void)) x getAlternateURLForImage completion
let actionSheetAssistant5 x ~shareElementWithImage ~rect self = msg_send ~self ~cmd:(selector "actionSheetAssistant:shareElementWithImage:rect:") ~typ:(id @-> id @-> CGRect.t @-> returning (void)) x shareElementWithImage rect
let actionSheetAssistant6 x ~shareElementWithURL ~rect self = msg_send ~self ~cmd:(selector "actionSheetAssistant:shareElementWithURL:rect:") ~typ:(id @-> id @-> CGRect.t @-> returning (void)) x shareElementWithURL rect
let actionSheetAssistantDidDismissContextMenu x self = msg_send ~self ~cmd:(selector "actionSheetAssistantDidDismissContextMenu:") ~typ:(id @-> returning (void)) x
let actionSheetAssistantDidShowContextMenu x self = msg_send ~self ~cmd:(selector "actionSheetAssistantDidShowContextMenu:") ~typ:(id @-> returning (void)) x
let actionSheetAssistantDidStopInteraction x self = msg_send ~self ~cmd:(selector "actionSheetAssistantDidStopInteraction:") ~typ:(id @-> returning (void)) x
let adjustSelectionWithDelta x ~completionHandler self = msg_send ~self ~cmd:(selector "adjustSelectionWithDelta:completionHandler:") ~typ:(NSRange.t @-> ptr void @-> returning (void)) x completionHandler
let alignCenterForWebView x self = msg_send ~self ~cmd:(selector "alignCenterForWebView:") ~typ:(id @-> returning (void)) x
let alignJustifiedForWebView x self = msg_send ~self ~cmd:(selector "alignJustifiedForWebView:") ~typ:(id @-> returning (void)) x
let alignLeftForWebView x self = msg_send ~self ~cmd:(selector "alignLeftForWebView:") ~typ:(id @-> returning (void)) x
let alignRightForWebView x self = msg_send ~self ~cmd:(selector "alignRightForWebView:") ~typ:(id @-> returning (void)) x
let alternativesForSelectedText self = msg_send ~self ~cmd:(selector "alternativesForSelectedText") ~typ:(returning (id))
let applyAutocorrection x ~toString ~withCompletionHandler self = msg_send ~self ~cmd:(selector "applyAutocorrection:toString:withCompletionHandler:") ~typ:(id @-> id @-> ptr void @-> returning (void)) x toString withCompletionHandler
let assignLegacyDataForContextMenuInteraction self = msg_send ~self ~cmd:(selector "assignLegacyDataForContextMenuInteraction") ~typ:(returning (void))
let autocorrectionData self = msg_send ~self ~cmd:(selector "autocorrectionData") ~typ:(returning (ptr (void)))
let automaticallySelectedOverlay self = msg_send ~self ~cmd:(selector "automaticallySelectedOverlay") ~typ:(returning (id))
let baseWritingDirectionForPosition x ~inDirection self = msg_send ~self ~cmd:(selector "baseWritingDirectionForPosition:inDirection:") ~typ:(id @-> llong @-> returning (llong)) x inDirection
let becomeFirstResponder self = msg_send ~self ~cmd:(selector "becomeFirstResponder") ~typ:(returning (bool))
let becomeFirstResponderForWebView self = msg_send ~self ~cmd:(selector "becomeFirstResponderForWebView") ~typ:(returning (bool))
let beginSelectionChange self = msg_send ~self ~cmd:(selector "beginSelectionChange") ~typ:(returning (void))
let beginSelectionInDirection x ~completionHandler self = msg_send ~self ~cmd:(selector "beginSelectionInDirection:completionHandler:") ~typ:(llong @-> ptr void @-> returning (void)) x completionHandler
let beginningOfDocument self = msg_send ~self ~cmd:(selector "beginningOfDocument") ~typ:(returning (id))
let browsingContextController self = msg_send ~self ~cmd:(selector "browsingContextController") ~typ:(returning (id))
let canBecomeFirstResponder self = msg_send ~self ~cmd:(selector "canBecomeFirstResponder") ~typ:(returning (bool))
let canBecomeFirstResponderForWebView self = msg_send ~self ~cmd:(selector "canBecomeFirstResponderForWebView") ~typ:(returning (bool))
let canBecomeFocused self = msg_send ~self ~cmd:(selector "canBecomeFocused") ~typ:(returning (bool))
let canPerformAction x ~withSender self = msg_send ~self ~cmd:(selector "canPerformAction:withSender:") ~typ:(_SEL @-> id @-> returning (bool)) x withSender
let canPerformActionForWebView x ~withSender self = msg_send ~self ~cmd:(selector "canPerformActionForWebView:withSender:") ~typ:(_SEL @-> id @-> returning (bool)) x withSender
let canShowNonEmptySelectionView self = msg_send ~self ~cmd:(selector "canShowNonEmptySelectionView") ~typ:(returning (bool))
let cancelActiveTextInteractionGestures self = msg_send ~self ~cmd:(selector "cancelActiveTextInteractionGestures") ~typ:(returning (void))
let cancelAutoscroll self = msg_send ~self ~cmd:(selector "cancelAutoscroll") ~typ:(returning (void))
let cancelPointersForGestureRecognizer x self = msg_send ~self ~cmd:(selector "cancelPointersForGestureRecognizer:") ~typ:(id @-> returning (void)) x
let captureTextFromCamera x self = msg_send ~self ~cmd:(selector "captureTextFromCamera:") ~typ:(id @-> returning (void)) x
let captureTextFromCameraForWebView x self = msg_send ~self ~cmd:(selector "captureTextFromCameraForWebView:") ~typ:(id @-> returning (void)) x
let caretRectForPosition x self = msg_send ~self ~cmd:(selector "caretRectForPosition:") ~typ:(id @-> returning (CGRect.t)) x
let changeSelectionWithGestureAt x ~withGesture ~withState self = msg_send ~self ~cmd:(selector "changeSelectionWithGestureAt:withGesture:withState:") ~typ:(CGPoint.t @-> llong @-> llong @-> returning (void)) x withGesture withState
let changeSelectionWithGestureAt' x ~withGesture ~withState ~withFlags self = msg_send ~self ~cmd:(selector "changeSelectionWithGestureAt:withGesture:withState:withFlags:") ~typ:(CGPoint.t @-> llong @-> llong @-> llong @-> returning (void)) x withGesture withState withFlags
let changeSelectionWithTouchAt x ~withSelectionTouch ~baseIsStart ~withFlags self = msg_send ~self ~cmd:(selector "changeSelectionWithTouchAt:withSelectionTouch:baseIsStart:withFlags:") ~typ:(CGPoint.t @-> llong @-> bool @-> llong @-> returning (void)) x withSelectionTouch baseIsStart withFlags
let changeSelectionWithTouchesFrom x ~to_ ~withGesture ~withState self = msg_send ~self ~cmd:(selector "changeSelectionWithTouchesFrom:to:withGesture:withState:") ~typ:(CGPoint.t @-> CGPoint.t @-> llong @-> llong @-> returning (void)) x to_ withGesture withState
let characterBeforeCaretSelection self = msg_send ~self ~cmd:(selector "characterBeforeCaretSelection") ~typ:(returning (ushort))
let characterRangeAtPoint x self = msg_send ~self ~cmd:(selector "characterRangeAtPoint:") ~typ:(CGPoint.t @-> returning (id)) x
let characterRangeByExtendingPosition x ~inDirection self = msg_send ~self ~cmd:(selector "characterRangeByExtendingPosition:inDirection:") ~typ:(id @-> llong @-> returning (id)) x inDirection
let cleanUpDragSourceSessionState self = msg_send ~self ~cmd:(selector "cleanUpDragSourceSessionState") ~typ:(returning (void))
let cleanUpInteraction self = msg_send ~self ~cmd:(selector "cleanUpInteraction") ~typ:(returning (void))
let cleanUpInteractionPreviewContainers self = msg_send ~self ~cmd:(selector "cleanUpInteractionPreviewContainers") ~typ:(returning (void))
let cleanUpScribbleInteraction self = msg_send ~self ~cmd:(selector "cleanUpScribbleInteraction") ~typ:(returning (void))
let clearSelection self = msg_send ~self ~cmd:(selector "clearSelection") ~typ:(returning (void))
let clearTextIndicator x self = msg_send ~self ~cmd:(selector "clearTextIndicator:") ~typ:(bool @-> returning (void)) x
let closestPositionToPoint x self = msg_send ~self ~cmd:(selector "closestPositionToPoint:") ~typ:(CGPoint.t @-> returning (id)) x
let closestPositionToPoint' x ~withinRange self = msg_send ~self ~cmd:(selector "closestPositionToPoint:withinRange:") ~typ:(CGPoint.t @-> id @-> returning (id)) x withinRange
let comparePosition x ~toPosition self = msg_send ~self ~cmd:(selector "comparePosition:toPosition:") ~typ:(id @-> id @-> returning (llong)) x toPosition
let computeClientAndGlobalPointsForDropSession x ~outClientPoint ~outGlobalPoint self = msg_send ~self ~cmd:(selector "computeClientAndGlobalPointsForDropSession:outClientPoint:outGlobalPoint:") ~typ:(id @-> ptr (CGPoint.t) @-> ptr (CGPoint.t) @-> returning (void)) x outClientPoint outGlobalPoint
let contactPickerDidDismiss x self = msg_send ~self ~cmd:(selector "contactPickerDidDismiss:") ~typ:(id @-> returning (void)) x
let contactPickerDidPresent x self = msg_send ~self ~cmd:(selector "contactPickerDidPresent:") ~typ:(id @-> returning (void)) x
let containerForContextMenuHintPreviews self = msg_send ~self ~cmd:(selector "containerForContextMenuHintPreviews") ~typ:(returning (id))
let containerForDragPreviews self = msg_send ~self ~cmd:(selector "containerForDragPreviews") ~typ:(returning (id))
let containerForDropPreviews self = msg_send ~self ~cmd:(selector "containerForDropPreviews") ~typ:(returning (id))
let contextMenuInteraction x ~configurationForMenuAtLocation self = msg_send ~self ~cmd:(selector "contextMenuInteraction:configurationForMenuAtLocation:") ~typ:(id @-> CGPoint.t @-> returning (id)) x configurationForMenuAtLocation
let contextMenuInteraction1 x ~previewForDismissingMenuWithConfiguration self = msg_send ~self ~cmd:(selector "contextMenuInteraction:previewForDismissingMenuWithConfiguration:") ~typ:(id @-> id @-> returning (id)) x previewForDismissingMenuWithConfiguration
let contextMenuInteraction2 x ~previewForHighlightingMenuWithConfiguration self = msg_send ~self ~cmd:(selector "contextMenuInteraction:previewForHighlightingMenuWithConfiguration:") ~typ:(id @-> id @-> returning (id)) x previewForHighlightingMenuWithConfiguration
let contextMenuInteraction3 x ~willDisplayMenuForConfiguration ~animator self = msg_send ~self ~cmd:(selector "contextMenuInteraction:willDisplayMenuForConfiguration:animator:") ~typ:(id @-> id @-> id @-> returning (void)) x willDisplayMenuForConfiguration animator
let contextMenuInteraction4 x ~willEndForConfiguration ~animator self = msg_send ~self ~cmd:(selector "contextMenuInteraction:willEndForConfiguration:animator:") ~typ:(id @-> id @-> id @-> returning (void)) x willEndForConfiguration animator
let contextMenuInteraction5 x ~willPerformPreviewActionForMenuWithConfiguration ~animator self = msg_send ~self ~cmd:(selector "contextMenuInteraction:willPerformPreviewActionForMenuWithConfiguration:animator:") ~typ:(id @-> id @-> id @-> returning (void)) x willPerformPreviewActionForMenuWithConfiguration animator
let continueContextMenuInteraction x self = msg_send ~self ~cmd:(selector "continueContextMenuInteraction:") ~typ:(ptr void @-> returning (void)) x
let continueContextMenuInteractionWithDataDetectors x self = msg_send ~self ~cmd:(selector "continueContextMenuInteractionWithDataDetectors:") ~typ:(ptr void @-> returning (void)) x
let copy x self = msg_send ~self ~cmd:(selector "copy:") ~typ:(id @-> returning (void)) x
let copyForWebView x self = msg_send ~self ~cmd:(selector "copyForWebView:") ~typ:(id @-> returning (void)) x
let createTargetedContextMenuHintForActionSheetAssistant x self = msg_send ~self ~cmd:(selector "createTargetedContextMenuHintForActionSheetAssistant:") ~typ:(id @-> returning (id)) x
let currentDragOrDropSession self = msg_send ~self ~cmd:(selector "currentDragOrDropSession") ~typ:(returning (id))
let cut x self = msg_send ~self ~cmd:(selector "cut:") ~typ:(id @-> returning (void)) x
let cutForWebView x self = msg_send ~self ~cmd:(selector "cutForWebView:") ~typ:(id @-> returning (void)) x
let dataDetectionContextForActionSheetAssistant x ~positionInformation self = msg_send ~self ~cmd:(selector "dataDetectionContextForActionSheetAssistant:positionInformation:") ~typ:(id @-> ptr (void) @-> returning (id)) x positionInformation
let dataDetectionContextForPositionInformation x self = msg_send ~self ~cmd:(selector "dataDetectionContextForPositionInformation:") ~typ:(ptr (void) @-> returning (id)) x
let dataListTextSuggestions self = msg_send ~self ~cmd:(selector "dataListTextSuggestions") ~typ:(returning (id))
let dataListTextSuggestionsInputView self = msg_send ~self ~cmd:(selector "dataListTextSuggestionsInputView") ~typ:(returning (id))
let dateTimeInputControl self = msg_send ~self ~cmd:(selector "dateTimeInputControl") ~typ:(returning (id))
let dealloc self = msg_send ~self ~cmd:(selector "dealloc") ~typ:(returning (void))
let decreaseSize x self = msg_send ~self ~cmd:(selector "decreaseSize:") ~typ:(id @-> returning (void)) x
let decreaseSizeForWebView x self = msg_send ~self ~cmd:(selector "decreaseSizeForWebView:") ~typ:(id @-> returning (void)) x
let deferringGestureRecognizer x ~didEndTouchesWithEvent self = msg_send ~self ~cmd:(selector "deferringGestureRecognizer:didEndTouchesWithEvent:") ~typ:(id @-> id @-> returning (void)) x didEndTouchesWithEvent
let deferringGestureRecognizer1 x ~didTransitionToState self = msg_send ~self ~cmd:(selector "deferringGestureRecognizer:didTransitionToState:") ~typ:(id @-> llong @-> returning (void)) x didTransitionToState
let deferringGestureRecognizer2 x ~shouldDeferOtherGestureRecognizer self = msg_send ~self ~cmd:(selector "deferringGestureRecognizer:shouldDeferOtherGestureRecognizer:") ~typ:(id @-> id @-> returning (bool)) x shouldDeferOtherGestureRecognizer
let deferringGestureRecognizer3 x ~willBeginTouchesWithEvent self = msg_send ~self ~cmd:(selector "deferringGestureRecognizer:willBeginTouchesWithEvent:") ~typ:(id @-> id @-> returning (bool)) x willBeginTouchesWithEvent
let deferringGestures self = msg_send ~self ~cmd:(selector "deferringGestures") ~typ:(returning (id))
let deleteBackward self = msg_send ~self ~cmd:(selector "deleteBackward") ~typ:(returning (void))
let didFinishScrolling self = msg_send ~self ~cmd:(selector "didFinishScrolling") ~typ:(returning (void))
let didInterruptScrolling self = msg_send ~self ~cmd:(selector "didInterruptScrolling") ~typ:(returning (void))
let didMoveToWindow self = msg_send ~self ~cmd:(selector "didMoveToWindow") ~typ:(returning (void))
let didUpdateFocusInContext x ~withAnimationCoordinator self = msg_send ~self ~cmd:(selector "didUpdateFocusInContext:withAnimationCoordinator:") ~typ:(id @-> id @-> returning (void)) x withAnimationCoordinator
let didZoomToScale x self = msg_send ~self ~cmd:(selector "didZoomToScale:") ~typ:(double @-> returning (void)) x
let dismissFilePicker self = msg_send ~self ~cmd:(selector "dismissFilePicker") ~typ:(returning (void))
let doAfterEditorStateUpdateAfterFocusingElement x self = msg_send ~self ~cmd:(selector "doAfterEditorStateUpdateAfterFocusingElement:") ~typ:(ptr void @-> returning (void)) x
let dragInteraction x ~itemsForBeginningSession self = msg_send ~self ~cmd:(selector "dragInteraction:itemsForBeginningSession:") ~typ:(id @-> id @-> returning (id)) x itemsForBeginningSession
let dragInteraction1 x ~sessionDidTransferItems self = msg_send ~self ~cmd:(selector "dragInteraction:sessionDidTransferItems:") ~typ:(id @-> id @-> returning (void)) x sessionDidTransferItems
let dragInteraction2 x ~sessionWillBegin self = msg_send ~self ~cmd:(selector "dragInteraction:sessionWillBegin:") ~typ:(id @-> id @-> returning (void)) x sessionWillBegin
let dragInteraction3 x ~item ~willAnimateCancelWithAnimator self = msg_send ~self ~cmd:(selector "dragInteraction:item:willAnimateCancelWithAnimator:") ~typ:(id @-> id @-> id @-> returning (void)) x item willAnimateCancelWithAnimator
let dragInteraction4 x ~previewForCancellingItem ~withDefault self = msg_send ~self ~cmd:(selector "dragInteraction:previewForCancellingItem:withDefault:") ~typ:(id @-> id @-> id @-> returning (id)) x previewForCancellingItem withDefault
let dragInteraction5 x ~previewForLiftingItem ~session self = msg_send ~self ~cmd:(selector "dragInteraction:previewForLiftingItem:session:") ~typ:(id @-> id @-> id @-> returning (id)) x previewForLiftingItem session
let dragInteraction6 x ~session ~didEndWithOperation self = msg_send ~self ~cmd:(selector "dragInteraction:session:didEndWithOperation:") ~typ:(id @-> id @-> ullong @-> returning (void)) x session didEndWithOperation
let dragInteraction7 x ~willAnimateLiftWithAnimator ~session self = msg_send ~self ~cmd:(selector "dragInteraction:willAnimateLiftWithAnimator:session:") ~typ:(id @-> id @-> id @-> returning (void)) x willAnimateLiftWithAnimator session
let dragLiftDelay self = msg_send ~self ~cmd:(selector "dragLiftDelay") ~typ:(returning (double))
let dropInteraction x ~canHandleSession self = msg_send ~self ~cmd:(selector "dropInteraction:canHandleSession:") ~typ:(id @-> id @-> returning (bool)) x canHandleSession
let dropInteraction1 x ~concludeDrop self = msg_send ~self ~cmd:(selector "dropInteraction:concludeDrop:") ~typ:(id @-> id @-> returning (void)) x concludeDrop
let dropInteraction2 x ~performDrop self = msg_send ~self ~cmd:(selector "dropInteraction:performDrop:") ~typ:(id @-> id @-> returning (void)) x performDrop
let dropInteraction3 x ~sessionDidEnd self = msg_send ~self ~cmd:(selector "dropInteraction:sessionDidEnd:") ~typ:(id @-> id @-> returning (void)) x sessionDidEnd
let dropInteraction4 x ~sessionDidEnter self = msg_send ~self ~cmd:(selector "dropInteraction:sessionDidEnter:") ~typ:(id @-> id @-> returning (void)) x sessionDidEnter
let dropInteraction5 x ~sessionDidExit self = msg_send ~self ~cmd:(selector "dropInteraction:sessionDidExit:") ~typ:(id @-> id @-> returning (void)) x sessionDidExit
let dropInteraction6 x ~sessionDidUpdate self = msg_send ~self ~cmd:(selector "dropInteraction:sessionDidUpdate:") ~typ:(id @-> id @-> returning (id)) x sessionDidUpdate
let dropInteraction7 x ~item ~willAnimateDropWithAnimator self = msg_send ~self ~cmd:(selector "dropInteraction:item:willAnimateDropWithAnimator:") ~typ:(id @-> id @-> id @-> returning (void)) x item willAnimateDropWithAnimator
let dropInteraction8 x ~previewForDroppingItem ~withDefault self = msg_send ~self ~cmd:(selector "dropInteraction:previewForDroppingItem:withDefault:") ~typ:(id @-> id @-> id @-> returning (id)) x previewForDroppingItem withDefault
let endEditingAndUpdateFocusAppearanceWithReason x self = msg_send ~self ~cmd:(selector "endEditingAndUpdateFocusAppearanceWithReason:") ~typ:(llong @-> returning (void)) x
let endOfDocument self = msg_send ~self ~cmd:(selector "endOfDocument") ~typ:(returning (id))
let endSelectionChange self = msg_send ~self ~cmd:(selector "endSelectionChange") ~typ:(returning (void))
let executeEditCommandWithCallback x self = msg_send ~self ~cmd:(selector "executeEditCommandWithCallback:") ~typ:(id @-> returning (void)) x
let filePickerAcceptedTypeIdentifiers self = msg_send ~self ~cmd:(selector "filePickerAcceptedTypeIdentifiers") ~typ:(returning (id))
let fileUploadPanelDestinationIsManaged x self = msg_send ~self ~cmd:(selector "fileUploadPanelDestinationIsManaged:") ~typ:(id @-> returning (bool)) x
let fileUploadPanelDidDismiss x self = msg_send ~self ~cmd:(selector "fileUploadPanelDidDismiss:") ~typ:(id @-> returning (void)) x
let firstRectForRange x self = msg_send ~self ~cmd:(selector "firstRectForRange:") ~typ:(id @-> returning (CGRect.t)) x
let focusedElementInformation self = msg_send ~self ~cmd:(selector "focusedElementInformation") ~typ:(returning (ptr (void)))
let focusedSelectElementOptions self = msg_send ~self ~cmd:(selector "focusedSelectElementOptions") ~typ:(returning (ptr (void)))
let fontForCaretSelection self = msg_send ~self ~cmd:(selector "fontForCaretSelection") ~typ:(returning (id))
let formAccessoryView self = msg_send ~self ~cmd:(selector "formAccessoryView") ~typ:(returning (id))
let formInputLabel self = msg_send ~self ~cmd:(selector "formInputLabel") ~typ:(returning (id))
let generateSyntheticEditingCommand x self = msg_send ~self ~cmd:(selector "generateSyntheticEditingCommand:") ~typ:(bool @-> returning (void)) x
let gestureRecognizer x ~canBePreventedByGestureRecognizer self = msg_send ~self ~cmd:(selector "gestureRecognizer:canBePreventedByGestureRecognizer:") ~typ:(id @-> id @-> returning (bool)) x canBePreventedByGestureRecognizer
let gestureRecognizer1 x ~canPreventGestureRecognizer self = msg_send ~self ~cmd:(selector "gestureRecognizer:canPreventGestureRecognizer:") ~typ:(id @-> id @-> returning (bool)) x canPreventGestureRecognizer
let gestureRecognizer2 x ~isInterruptingMomentumScrollingWithEvent self = msg_send ~self ~cmd:(selector "gestureRecognizer:isInterruptingMomentumScrollingWithEvent:") ~typ:(id @-> id @-> returning (bool)) x isInterruptingMomentumScrollingWithEvent
let gestureRecognizer3 x ~shouldBeRequiredToFailByGestureRecognizer self = msg_send ~self ~cmd:(selector "gestureRecognizer:shouldBeRequiredToFailByGestureRecognizer:") ~typ:(id @-> id @-> returning (bool)) x shouldBeRequiredToFailByGestureRecognizer
let gestureRecognizer4 x ~shouldIgnoreWebTouchWithEvent self = msg_send ~self ~cmd:(selector "gestureRecognizer:shouldIgnoreWebTouchWithEvent:") ~typ:(id @-> id @-> returning (bool)) x shouldIgnoreWebTouchWithEvent
let gestureRecognizer5 x ~shouldReceivePress self = msg_send ~self ~cmd:(selector "gestureRecognizer:shouldReceivePress:") ~typ:(id @-> id @-> returning (bool)) x shouldReceivePress
let gestureRecognizer6 x ~shouldReceiveTouch self = msg_send ~self ~cmd:(selector "gestureRecognizer:shouldReceiveTouch:") ~typ:(id @-> id @-> returning (bool)) x shouldReceiveTouch
let gestureRecognizer7 x ~shouldRecognizeSimultaneouslyWithGestureRecognizer self = msg_send ~self ~cmd:(selector "gestureRecognizer:shouldRecognizeSimultaneouslyWithGestureRecognizer:") ~typ:(id @-> id @-> returning (bool)) x shouldRecognizeSimultaneouslyWithGestureRecognizer
let gestureRecognizer8 x ~shouldRequireFailureOfGestureRecognizer self = msg_send ~self ~cmd:(selector "gestureRecognizer:shouldRequireFailureOfGestureRecognizer:") ~typ:(id @-> id @-> returning (bool)) x shouldRequireFailureOfGestureRecognizer
let gestureRecognizerConsistencyEnforcer self = msg_send ~self ~cmd:(selector "gestureRecognizerConsistencyEnforcer") ~typ:(returning (ptr (void)))
let gestureRecognizerMayDoubleTapToZoomWebView x self = msg_send ~self ~cmd:(selector "gestureRecognizerMayDoubleTapToZoomWebView:") ~typ:(id @-> returning (bool)) x
let gestureRecognizerMayPanWebView x self = msg_send ~self ~cmd:(selector "gestureRecognizerMayPanWebView:") ~typ:(id @-> returning (bool)) x
let gestureRecognizerMayPinchToZoomWebView x self = msg_send ~self ~cmd:(selector "gestureRecognizerMayPinchToZoomWebView:") ~typ:(id @-> returning (bool)) x
let gestureRecognizerShouldBegin x self = msg_send ~self ~cmd:(selector "gestureRecognizerShouldBegin:") ~typ:(id @-> returning (bool)) x
let handleKeyWebEvent x self = msg_send ~self ~cmd:(selector "handleKeyWebEvent:") ~typ:(id @-> returning (void)) x
let handleKeyWebEvent' x ~withCompletionHandler self = msg_send ~self ~cmd:(selector "handleKeyWebEvent:withCompletionHandler:") ~typ:(id @-> ptr void @-> returning (void)) x withCompletionHandler
let hasContent self = msg_send ~self ~cmd:(selector "hasContent") ~typ:(returning (bool))
let hasHiddenContentEditable self = msg_send ~self ~cmd:(selector "hasHiddenContentEditable") ~typ:(returning (bool))
let hasMarkedText self = msg_send ~self ~cmd:(selector "hasMarkedText") ~typ:(returning (bool))
let hasPendingImageAnalysisRequest self = msg_send ~self ~cmd:(selector "hasPendingImageAnalysisRequest") ~typ:(returning (bool))
let hasSelectablePositionAtPoint x self = msg_send ~self ~cmd:(selector "hasSelectablePositionAtPoint:") ~typ:(CGPoint.t @-> returning (bool)) x
let hasSelection self = msg_send ~self ~cmd:(selector "hasSelection") ~typ:(returning (bool))
let hasText self = msg_send ~self ~cmd:(selector "hasText") ~typ:(returning (bool))
let hitTest x ~withEvent self = msg_send ~self ~cmd:(selector "hitTest:withEvent:") ~typ:(CGPoint.t @-> id @-> returning (id)) x withEvent
let imageAnalysisGestureDidBegin x self = msg_send ~self ~cmd:(selector "imageAnalysisGestureDidBegin:") ~typ:(id @-> returning (void)) x
let imageAnalysisGestureDidFail x self = msg_send ~self ~cmd:(selector "imageAnalysisGestureDidFail:") ~typ:(id @-> returning (void)) x
let imageAnalysisGestureDidTimeOut x self = msg_send ~self ~cmd:(selector "imageAnalysisGestureDidTimeOut:") ~typ:(id @-> returning (void)) x
let imageAnalysisGestureRecognizer self = msg_send ~self ~cmd:(selector "imageAnalysisGestureRecognizer") ~typ:(returning (id))
let imageAnalyzer self = msg_send ~self ~cmd:(selector "imageAnalyzer") ~typ:(returning (id))
let increaseSize x self = msg_send ~self ~cmd:(selector "increaseSize:") ~typ:(id @-> returning (void)) x
let increaseSizeForWebView x self = msg_send ~self ~cmd:(selector "increaseSizeForWebView:") ~typ:(id @-> returning (void)) x
let indentForWebView x self = msg_send ~self ~cmd:(selector "indentForWebView:") ~typ:(id @-> returning (void)) x
let indirectScribbleInteraction x ~didFinishWritingInElement self = msg_send ~self ~cmd:(selector "indirectScribbleInteraction:didFinishWritingInElement:") ~typ:(id @-> id @-> returning (void)) x didFinishWritingInElement
let indirectScribbleInteraction1 x ~frameForElement self = msg_send ~self ~cmd:(selector "indirectScribbleInteraction:frameForElement:") ~typ:(id @-> id @-> returning (CGRect.t)) x frameForElement
let indirectScribbleInteraction2 x ~isElementFocused self = msg_send ~self ~cmd:(selector "indirectScribbleInteraction:isElementFocused:") ~typ:(id @-> id @-> returning (bool)) x isElementFocused
let indirectScribbleInteraction3 x ~willBeginWritingInElement self = msg_send ~self ~cmd:(selector "indirectScribbleInteraction:willBeginWritingInElement:") ~typ:(id @-> id @-> returning (void)) x willBeginWritingInElement
let indirectScribbleInteraction4 x ~requestElementsInRect ~completion self = msg_send ~self ~cmd:(selector "indirectScribbleInteraction:requestElementsInRect:completion:") ~typ:(id @-> CGRect.t @-> ptr void @-> returning (void)) x requestElementsInRect completion
let indirectScribbleInteraction5 x ~focusElementIfNeeded ~referencePoint ~completion self = msg_send ~self ~cmd:(selector "indirectScribbleInteraction:focusElementIfNeeded:referencePoint:completion:") ~typ:(id @-> id @-> CGPoint.t @-> ptr void @-> returning (void)) x focusElementIfNeeded referencePoint completion
let inputAccessoryView self = msg_send ~self ~cmd:(selector "inputAccessoryView") ~typ:(returning (id))
let inputAccessoryViewForWebView self = msg_send ~self ~cmd:(selector "inputAccessoryViewForWebView") ~typ:(returning (id))
let inputAssistantItem self = msg_send ~self ~cmd:(selector "inputAssistantItem") ~typ:(returning (id))
let inputAssistantItemForWebView self = msg_send ~self ~cmd:(selector "inputAssistantItemForWebView") ~typ:(returning (id))
let inputDelegate self = msg_send ~self ~cmd:(selector "inputDelegate") ~typ:(returning (id))
let inputLabelText self = msg_send ~self ~cmd:(selector "inputLabelText") ~typ:(returning (id))
let inputView self = msg_send ~self ~cmd:(selector "inputView") ~typ:(returning (id))
let inputViewForWebView self = msg_send ~self ~cmd:(selector "inputViewForWebView") ~typ:(returning (id))
let insertNestedOrderedListForWebView x self = msg_send ~self ~cmd:(selector "insertNestedOrderedListForWebView:") ~typ:(id @-> returning (void)) x
let insertNestedUnorderedListForWebView x self = msg_send ~self ~cmd:(selector "insertNestedUnorderedListForWebView:") ~typ:(id @-> returning (void)) x
let insertOrderedListForWebView x self = msg_send ~self ~cmd:(selector "insertOrderedListForWebView:") ~typ:(id @-> returning (void)) x
let insertText x self = msg_send ~self ~cmd:(selector "insertText:") ~typ:(id @-> returning (void)) x
let insertText' x ~alternatives ~style self = msg_send ~self ~cmd:(selector "insertText:alternatives:style:") ~typ:(id @-> id @-> llong @-> returning (void)) x alternatives style
let insertTextPlaceholderWithSize x ~completionHandler self = msg_send ~self ~cmd:(selector "insertTextPlaceholderWithSize:completionHandler:") ~typ:(CGSize.t @-> ptr void @-> returning (void)) x completionHandler
let insertTextSuggestion x self = msg_send ~self ~cmd:(selector "insertTextSuggestion:") ~typ:(id @-> returning (void)) x
let insertUnorderedListForWebView x self = msg_send ~self ~cmd:(selector "insertUnorderedListForWebView:") ~typ:(id @-> returning (void)) x
let insertionPointColor self = msg_send ~self ~cmd:(selector "insertionPointColor") ~typ:(returning (id))
let interactionAssistant self = msg_send ~self ~cmd:(selector "interactionAssistant") ~typ:(returning (id))
let interfaceOrientation self = msg_send ~self ~cmd:(selector "interfaceOrientation") ~typ:(returning (llong))
let inverseScale self = msg_send ~self ~cmd:(selector "inverseScale") ~typ:(returning (double))
let isAnimatingDragCancel self = msg_send ~self ~cmd:(selector "isAnimatingDragCancel") ~typ:(returning (bool))
let isAnyTouchOverActiveArea x self = msg_send ~self ~cmd:(selector "isAnyTouchOverActiveArea:") ~typ:(id @-> returning (bool)) x
let isEditable self = msg_send ~self ~cmd:(selector "isEditable") ~typ:(returning (bool))
let isFocusingElement self = msg_send ~self ~cmd:(selector "isFocusingElement") ~typ:(returning (bool))
let isPosition x ~atBoundary ~inDirection self = msg_send ~self ~cmd:(selector "isPosition:atBoundary:inDirection:") ~typ:(id @-> llong @-> llong @-> returning (bool)) x atBoundary inDirection
let isPosition' x ~withinTextUnit ~inDirection self = msg_send ~self ~cmd:(selector "isPosition:withinTextUnit:inDirection:") ~typ:(id @-> llong @-> llong @-> returning (bool)) x withinTextUnit inDirection
let isReplaceAllowed self = msg_send ~self ~cmd:(selector "isReplaceAllowed") ~typ:(returning (bool))
let isResigningFirstResponder self = msg_send ~self ~cmd:(selector "isResigningFirstResponder") ~typ:(returning (bool))
let isScrollableForKeyboardScrollViewAnimator x self = msg_send ~self ~cmd:(selector "isScrollableForKeyboardScrollViewAnimator:") ~typ:(id @-> returning (bool)) x
let isShowingDataListSuggestions self = msg_send ~self ~cmd:(selector "isShowingDataListSuggestions") ~typ:(returning (bool))
let isShowingInspectorIndication self = msg_send ~self ~cmd:(selector "isShowingInspectorIndication") ~typ:(returning (bool))
let keyboardScrollViewAnimator x ~distanceForIncrement ~inDirection self = msg_send ~self ~cmd:(selector "keyboardScrollViewAnimator:distanceForIncrement:inDirection:") ~typ:(id @-> bool @-> bool @-> returning (double)) x distanceForIncrement inDirection
let keyboardScrollViewAnimatorDidFinishScrolling x self = msg_send ~self ~cmd:(selector "keyboardScrollViewAnimatorDidFinishScrolling:") ~typ:(id @-> returning (void)) x
let keyboardScrollViewAnimatorWillScroll x self = msg_send ~self ~cmd:(selector "keyboardScrollViewAnimatorWillScroll:") ~typ:(id @-> returning (void)) x
let lastInteractionLocation self = msg_send ~self ~cmd:(selector "lastInteractionLocation") ~typ:(returning (CGPoint.t))
let makeTextWritingDirectionLeftToRight x self = msg_send ~self ~cmd:(selector "makeTextWritingDirectionLeftToRight:") ~typ:(id @-> returning (void)) x
let makeTextWritingDirectionLeftToRightForWebView x self = msg_send ~self ~cmd:(selector "makeTextWritingDirectionLeftToRightForWebView:") ~typ:(id @-> returning (void)) x
let makeTextWritingDirectionNatural x self = msg_send ~self ~cmd:(selector "makeTextWritingDirectionNatural:") ~typ:(id @-> returning (void)) x
let makeTextWritingDirectionNaturalForWebView x self = msg_send ~self ~cmd:(selector "makeTextWritingDirectionNaturalForWebView:") ~typ:(id @-> returning (void)) x
let makeTextWritingDirectionRightToLeft x self = msg_send ~self ~cmd:(selector "makeTextWritingDirectionRightToLeft:") ~typ:(id @-> returning (void)) x
let makeTextWritingDirectionRightToLeftForWebView x self = msg_send ~self ~cmd:(selector "makeTextWritingDirectionRightToLeftForWebView:") ~typ:(id @-> returning (void)) x
let markedText self = msg_send ~self ~cmd:(selector "markedText") ~typ:(returning (id))
let markedTextRange self = msg_send ~self ~cmd:(selector "markedTextRange") ~typ:(returning (id))
let markedTextStyle self = msg_send ~self ~cmd:(selector "markedTextStyle") ~typ:(returning (id))
let metadataDictionariesForDictationResults self = msg_send ~self ~cmd:(selector "metadataDictionariesForDictationResults") ~typ:(returning (id))
let modifierFlagsDidChangeFrom x ~to_ self = msg_send ~self ~cmd:(selector "modifierFlagsDidChangeFrom:to:") ~typ:(llong @-> llong @-> returning (void)) x to_
let mouseGestureRecognizerChanged x self = msg_send ~self ~cmd:(selector "mouseGestureRecognizerChanged:") ~typ:(id @-> returning (void)) x
let moveBackward x self = msg_send ~self ~cmd:(selector "moveBackward:") ~typ:(uint @-> returning (void)) x
let moveByOffset x self = msg_send ~self ~cmd:(selector "moveByOffset:") ~typ:(llong @-> returning (void)) x
let moveForward x self = msg_send ~self ~cmd:(selector "moveForward:") ~typ:(uint @-> returning (void)) x
let moveSelectionAtBoundary x ~inDirection ~completionHandler self = msg_send ~self ~cmd:(selector "moveSelectionAtBoundary:inDirection:completionHandler:") ~typ:(llong @-> llong @-> ptr void @-> returning (void)) x inDirection completionHandler
let observeValueForKeyPath x ~ofObject ~change ~context self = msg_send ~self ~cmd:(selector "observeValueForKeyPath:ofObject:change:context:") ~typ:(id @-> id @-> id @-> ptr (void) @-> returning (void)) x ofObject change context
let offsetFromPosition x ~toPosition self = msg_send ~self ~cmd:(selector "offsetFromPosition:toPosition:") ~typ:(id @-> id @-> returning (llong)) x toPosition
let outdentForWebView x self = msg_send ~self ~cmd:(selector "outdentForWebView:") ~typ:(id @-> returning (void)) x
let page self = msg_send ~self ~cmd:(selector "page") ~typ:(returning (ptr (void)))
let paste x self = msg_send ~self ~cmd:(selector "paste:") ~typ:(id @-> returning (void)) x
let pasteAndMatchStyle x self = msg_send ~self ~cmd:(selector "pasteAndMatchStyle:") ~typ:(id @-> returning (void)) x
let pasteAndMatchStyleForWebView x self = msg_send ~self ~cmd:(selector "pasteAndMatchStyleForWebView:") ~typ:(id @-> returning (void)) x
let pasteForWebView x self = msg_send ~self ~cmd:(selector "pasteForWebView:") ~typ:(id @-> returning (void)) x
let pasteWithCompletionHandler x self = msg_send ~self ~cmd:(selector "pasteWithCompletionHandler:") ~typ:(ptr void @-> returning (void)) x
let pointIsNearMarkedText x self = msg_send ~self ~cmd:(selector "pointIsNearMarkedText:") ~typ:(CGPoint.t @-> returning (bool)) x
let positionFromPosition x ~offset self = msg_send ~self ~cmd:(selector "positionFromPosition:offset:") ~typ:(id @-> llong @-> returning (id)) x offset
let positionFromPosition1 x ~inDirection ~offset self = msg_send ~self ~cmd:(selector "positionFromPosition:inDirection:offset:") ~typ:(id @-> llong @-> llong @-> returning (id)) x inDirection offset
let positionFromPosition2 x ~toBoundary ~inDirection self = msg_send ~self ~cmd:(selector "positionFromPosition:toBoundary:inDirection:") ~typ:(id @-> llong @-> llong @-> returning (id)) x toBoundary inDirection
let positionInformation self = msg_send ~self ~cmd:(selector "positionInformation") ~typ:(returning (ptr (void)))
let positionInformationHasImageOverlayDataDetector self = msg_send ~self ~cmd:(selector "positionInformationHasImageOverlayDataDetector") ~typ:(returning (bool))
let positionWithinRange x ~farthestInDirection self = msg_send ~self ~cmd:(selector "positionWithinRange:farthestInDirection:") ~typ:(id @-> llong @-> returning (id)) x farthestInDirection
let presentContextMenu x ~atLocation self = msg_send ~self ~cmd:(selector "presentContextMenu:atLocation:") ~typ:(id @-> CGPoint.t @-> returning (void)) x atLocation
let preventsPanningInXAxis self = msg_send ~self ~cmd:(selector "preventsPanningInXAxis") ~typ:(returning (bool))
let preventsPanningInYAxis self = msg_send ~self ~cmd:(selector "preventsPanningInYAxis") ~typ:(returning (bool))
let rangeEnclosingPosition x ~withGranularity ~inDirection self = msg_send ~self ~cmd:(selector "rangeEnclosingPosition:withGranularity:inDirection:") ~typ:(id @-> llong @-> llong @-> returning (id)) x withGranularity inDirection
let rectContainingCaretSelection self = msg_send ~self ~cmd:(selector "rectContainingCaretSelection") ~typ:(returning (CGRect.t))
let rectForNSRange x self = msg_send ~self ~cmd:(selector "rectForNSRange:") ~typ:(NSRange.t @-> returning (CGRect.t)) x
let reloadContextViewForPresentedListViewController self = msg_send ~self ~cmd:(selector "reloadContextViewForPresentedListViewController") ~typ:(returning (void))
let removeAnnotation x ~forSelectionOffset ~length self = msg_send ~self ~cmd:(selector "removeAnnotation:forSelectionOffset:length:") ~typ:(id @-> llong @-> ullong @-> returning (void)) x forSelectionOffset length
let removeContextMenuViewIfPossibleForActionSheetAssistant x self = msg_send ~self ~cmd:(selector "removeContextMenuViewIfPossibleForActionSheetAssistant:") ~typ:(id @-> returning (void)) x
let removeTextPlaceholder x ~willInsertText ~completionHandler self = msg_send ~self ~cmd:(selector "removeTextPlaceholder:willInsertText:completionHandler:") ~typ:(id @-> bool @-> ptr void @-> returning (void)) x willInsertText completionHandler
let replace x self = msg_send ~self ~cmd:(selector "replace:") ~typ:(id @-> returning (void)) x
let replaceDictatedText x ~withText self = msg_send ~self ~cmd:(selector "replaceDictatedText:withText:") ~typ:(id @-> id @-> returning (void)) x withText
let replaceForWebView x self = msg_send ~self ~cmd:(selector "replaceForWebView:") ~typ:(id @-> returning (void)) x
let replaceRange x ~withText self = msg_send ~self ~cmd:(selector "replaceRange:withText:") ~typ:(id @-> id @-> returning (void)) x withText
let replaceRangeWithTextWithoutClosingTyping x ~replacementText self = msg_send ~self ~cmd:(selector "replaceRangeWithTextWithoutClosingTyping:replacementText:") ~typ:(id @-> id @-> returning (void)) x replacementText
let replaceSelectionOffset x ~length ~withAnnotatedString ~relativeReplacementRange self = msg_send ~self ~cmd:(selector "replaceSelectionOffset:length:withAnnotatedString:relativeReplacementRange:") ~typ:(llong @-> ullong @-> id @-> NSRange.t @-> returning (void)) x length withAnnotatedString relativeReplacementRange
let replaceText x ~withText self = msg_send ~self ~cmd:(selector "replaceText:withText:") ~typ:(id @-> id @-> returning (void)) x withText
let requestAutocorrectionContextWithCompletionHandler x self = msg_send ~self ~cmd:(selector "requestAutocorrectionContextWithCompletionHandler:") ~typ:(ptr void @-> returning (void)) x
let requestAutocorrectionRectsForString x ~withCompletionHandler self = msg_send ~self ~cmd:(selector "requestAutocorrectionRectsForString:withCompletionHandler:") ~typ:(id @-> ptr void @-> returning (void)) x withCompletionHandler
let requestDictationContext x self = msg_send ~self ~cmd:(selector "requestDictationContext:") ~typ:(ptr void @-> returning (void)) x
let requestDocumentContext x ~completionHandler self = msg_send ~self ~cmd:(selector "requestDocumentContext:completionHandler:") ~typ:(id @-> ptr void @-> returning (void)) x completionHandler
let requestRectsToEvadeForSelectionCommandsWithCompletionHandler x self = msg_send ~self ~cmd:(selector "requestRectsToEvadeForSelectionCommandsWithCompletionHandler:") ~typ:(ptr void @-> returning (void)) x
let requestTextRecognition x ~imageData ~identifier ~completionHandler self = msg_send ~self ~cmd:(selector "requestTextRecognition:imageData:identifier:completionHandler:") ~typ:(id @-> ptr (void) @-> id @-> ptr (void) @-> returning (void)) x imageData identifier completionHandler
let requiresAccessoryView self = msg_send ~self ~cmd:(selector "requiresAccessoryView") ~typ:(returning (bool))
let requiresKeyEvents self = msg_send ~self ~cmd:(selector "requiresKeyEvents") ~typ:(returning (bool))
let resetShouldZoomToFocusRectAfterShowingKeyboard self = msg_send ~self ~cmd:(selector "resetShouldZoomToFocusRectAfterShowingKeyboard") ~typ:(returning (void))
let resignFirstResponder self = msg_send ~self ~cmd:(selector "resignFirstResponder") ~typ:(returning (bool))
let resignFirstResponderForWebView self = msg_send ~self ~cmd:(selector "resignFirstResponderForWebView") ~typ:(returning (bool))
let rootContentView self = msg_send ~self ~cmd:(selector "rootContentView") ~typ:(returning (id))
let runModalJavaScriptDialog x self = msg_send ~self ~cmd:(selector "runModalJavaScriptDialog:") ~typ:(ptr (void) @-> returning (void)) x
let scrollSelectionToVisible x self = msg_send ~self ~cmd:(selector "scrollSelectionToVisible:") ~typ:(bool @-> returning (void)) x
let scrollViewWillStartPanOrPinchGesture self = msg_send ~self ~cmd:(selector "scrollViewWillStartPanOrPinchGesture") ~typ:(returning (void))
let select x self = msg_send ~self ~cmd:(selector "select:") ~typ:(id @-> returning (void)) x
let selectAll self = msg_send ~self ~cmd:(selector "selectAll") ~typ:(returning (void))
let selectAll' x self = msg_send ~self ~cmd:(selector "selectAll:") ~typ:(id @-> returning (void)) x
let selectAllForWebView x self = msg_send ~self ~cmd:(selector "selectAllForWebView:") ~typ:(id @-> returning (void)) x
let selectControl self = msg_send ~self ~cmd:(selector "selectControl") ~typ:(returning (id))
let selectForWebView x self = msg_send ~self ~cmd:(selector "selectForWebView:") ~typ:(id @-> returning (void)) x
let selectFormAccessoryHasCheckedItemAtRow x self = msg_send ~self ~cmd:(selector "selectFormAccessoryHasCheckedItemAtRow:") ~typ:(llong @-> returning (bool)) x
let selectFormAccessoryPickerRow x self = msg_send ~self ~cmd:(selector "selectFormAccessoryPickerRow:") ~typ:(llong @-> returning (void)) x
let selectFormPopoverTitle self = msg_send ~self ~cmd:(selector "selectFormPopoverTitle") ~typ:(returning (id))
let selectPositionAtBoundary x ~inDirection ~fromPoint ~completionHandler self = msg_send ~self ~cmd:(selector "selectPositionAtBoundary:inDirection:fromPoint:completionHandler:") ~typ:(llong @-> llong @-> CGPoint.t @-> ptr void @-> returning (void)) x inDirection fromPoint completionHandler
let selectPositionAtPoint x ~completionHandler self = msg_send ~self ~cmd:(selector "selectPositionAtPoint:completionHandler:") ~typ:(CGPoint.t @-> ptr void @-> returning (void)) x completionHandler
let selectPositionAtPoint' x ~withContextRequest ~completionHandler self = msg_send ~self ~cmd:(selector "selectPositionAtPoint:withContextRequest:completionHandler:") ~typ:(CGPoint.t @-> id @-> ptr void @-> returning (void)) x withContextRequest completionHandler
let selectTextWithGranularity x ~atPoint ~completionHandler self = msg_send ~self ~cmd:(selector "selectTextWithGranularity:atPoint:completionHandler:") ~typ:(llong @-> CGPoint.t @-> ptr void @-> returning (void)) x atPoint completionHandler
let selectWordBackward self = msg_send ~self ~cmd:(selector "selectWordBackward") ~typ:(returning (void))
let selectWordForReplacement self = msg_send ~self ~cmd:(selector "selectWordForReplacement") ~typ:(returning (void))
let selectedDOMRange self = msg_send ~self ~cmd:(selector "selectedDOMRange") ~typ:(returning (id))
let selectedText self = msg_send ~self ~cmd:(selector "selectedText") ~typ:(returning (id))
let selectedTextForActionSheetAssistant x self = msg_send ~self ~cmd:(selector "selectedTextForActionSheetAssistant:") ~typ:(id @-> returning (id)) x
let selectedTextRange self = msg_send ~self ~cmd:(selector "selectedTextRange") ~typ:(returning (id))
let selectionBarColor self = msg_send ~self ~cmd:(selector "selectionBarColor") ~typ:(returning (id))
let selectionGranularity self = msg_send ~self ~cmd:(selector "selectionGranularity") ~typ:(returning (llong))
let selectionHighlightColor self = msg_send ~self ~cmd:(selector "selectionHighlightColor") ~typ:(returning (id))
let selectionRange self = msg_send ~self ~cmd:(selector "selectionRange") ~typ:(returning (NSRange.t))
let selectionRectsForRange x self = msg_send ~self ~cmd:(selector "selectionRectsForRange:") ~typ:(id @-> returning (id)) x
let setAttributedMarkedText x ~selectedRange self = msg_send ~self ~cmd:(selector "setAttributedMarkedText:selectedRange:") ~typ:(id @-> NSRange.t @-> returning (void)) x selectedRange
let setBaseWritingDirection x ~forRange self = msg_send ~self ~cmd:(selector "setBaseWritingDirection:forRange:") ~typ:(llong @-> id @-> returning (void)) x forRange
let setBottomBufferHeight x self = msg_send ~self ~cmd:(selector "setBottomBufferHeight:") ~typ:(double @-> returning (void)) x
let setContinuousSpellCheckingEnabled x self = msg_send ~self ~cmd:(selector "setContinuousSpellCheckingEnabled:") ~typ:(bool @-> returning (void)) x
let setDataListTextSuggestions x self = msg_send ~self ~cmd:(selector "setDataListTextSuggestions:") ~typ:(id @-> returning (void)) x
let setDataListTextSuggestionsInputView x self = msg_send ~self ~cmd:(selector "setDataListTextSuggestionsInputView:") ~typ:(id @-> returning (void)) x
let setInputDelegate x self = msg_send ~self ~cmd:(selector "setInputDelegate:") ~typ:(id @-> returning (void)) x
let setIsEditable x self = msg_send ~self ~cmd:(selector "setIsEditable:") ~typ:(bool @-> returning (bool)) x
let setMarkedText x self = msg_send ~self ~cmd:(selector "setMarkedText:") ~typ:(id @-> returning (void)) x
let setMarkedText' x ~selectedRange self = msg_send ~self ~cmd:(selector "setMarkedText:selectedRange:") ~typ:(id @-> NSRange.t @-> returning (void)) x selectedRange
let setMarkedTextStyle x self = msg_send ~self ~cmd:(selector "setMarkedTextStyle:") ~typ:(id @-> returning (void)) x
let setSelectedColorForColorPicker x self = msg_send ~self ~cmd:(selector "setSelectedColorForColorPicker:") ~typ:(id @-> returning (void)) x
let setSelectedDOMRange x ~affinityDownstream self = msg_send ~self ~cmd:(selector "setSelectedDOMRange:affinityDownstream:") ~typ:(id @-> bool @-> returning (void)) x affinityDownstream
let setSelectedTextRange x self = msg_send ~self ~cmd:(selector "setSelectedTextRange:") ~typ:(id @-> returning (void)) x
let setShowingInspectorIndication x self = msg_send ~self ~cmd:(selector "setShowingInspectorIndication:") ~typ:(bool @-> returning (void)) x
let setSizeChangedSinceLastVisibleContentRectUpdate x self = msg_send ~self ~cmd:(selector "setSizeChangedSinceLastVisibleContentRectUpdate:") ~typ:(bool @-> returning (void)) x
let setTextIndicatorAnimationProgress x self = msg_send ~self ~cmd:(selector "setTextIndicatorAnimationProgress:") ~typ:(float @-> returning (void)) x
let setTimePickerValueToHour x ~minute self = msg_send ~self ~cmd:(selector "setTimePickerValueToHour:minute:") ~typ:(llong @-> llong @-> returning (void)) x minute
let setUpDragAndDropInteractions self = msg_send ~self ~cmd:(selector "setUpDragAndDropInteractions") ~typ:(returning (void))
let setUpInteraction self = msg_send ~self ~cmd:(selector "setUpInteraction") ~typ:(returning (void))
let setUpMouseGestureRecognizer self = msg_send ~self ~cmd:(selector "setUpMouseGestureRecognizer") ~typ:(returning (void))
let setUpScribbleInteraction self = msg_send ~self ~cmd:(selector "setUpScribbleInteraction") ~typ:(returning (void))
let setUpTextSelectionAssistant self = msg_send ~self ~cmd:(selector "setUpTextSelectionAssistant") ~typ:(returning (void))
let shareSheet x ~willShowActivityItems self = msg_send ~self ~cmd:(selector "shareSheet:willShowActivityItems:") ~typ:(id @-> id @-> returning (void)) x willShowActivityItems
let shareSheetDidDismiss x self = msg_send ~self ~cmd:(selector "shareSheetDidDismiss:") ~typ:(id @-> returning (void)) x
let shouldAllowHidingSelectionCommands self = msg_send ~self ~cmd:(selector "shouldAllowHidingSelectionCommands") ~typ:(returning (bool))
let shouldDeferGestureDueToImageAnalysis x self = msg_send ~self ~cmd:(selector "shouldDeferGestureDueToImageAnalysis:") ~typ:(id @-> returning (bool)) x
let shouldHideSelectionWhenScrolling self = msg_send ~self ~cmd:(selector "shouldHideSelectionWhenScrolling") ~typ:(returning (bool))
let shouldIgnoreKeyboardWillHideNotification self = msg_send ~self ~cmd:(selector "shouldIgnoreKeyboardWillHideNotification") ~typ:(returning (bool))
let shouldShowAutomaticKeyboardUI self = msg_send ~self ~cmd:(selector "shouldShowAutomaticKeyboardUI") ~typ:(returning (bool))
let shouldSuppressUpdateCandidateView self = msg_send ~self ~cmd:(selector "shouldSuppressUpdateCandidateView") ~typ:(returning (bool))
let shouldSynthesizeKeyEvents self = msg_send ~self ~cmd:(selector "shouldSynthesizeKeyEvents") ~typ:(returning (bool))
let shouldUseMouseGestureRecognizer self = msg_send ~self ~cmd:(selector "shouldUseMouseGestureRecognizer") ~typ:(returning (bool))
let sizeChangedSinceLastVisibleContentRectUpdate self = msg_send ~self ~cmd:(selector "sizeChangedSinceLastVisibleContentRectUpdate") ~typ:(returning (bool))
let startAutoscroll x self = msg_send ~self ~cmd:(selector "startAutoscroll:") ~typ:(CGPoint.t @-> returning (void)) x
let startFadeOut self = msg_send ~self ~cmd:(selector "startFadeOut") ~typ:(returning (void))
let startRelinquishingFirstResponderToFocusedElement self = msg_send ~self ~cmd:(selector "startRelinquishingFirstResponderToFocusedElement") ~typ:(returning (void))
let stopRelinquishingFirstResponderToFocusedElement self = msg_send ~self ~cmd:(selector "stopRelinquishingFirstResponderToFocusedElement") ~typ:(returning (void))
let supportedPasteboardTypesForCurrentSelection self = msg_send ~self ~cmd:(selector "supportedPasteboardTypesForCurrentSelection") ~typ:(returning (id))
let supportsImagePaste self = msg_send ~self ~cmd:(selector "supportsImagePaste") ~typ:(returning (bool))
let supportsTextSelectionWithCharacterGranularity self = msg_send ~self ~cmd:(selector "supportsTextSelectionWithCharacterGranularity") ~typ:(returning (bool))
let takeTraitsFrom x self = msg_send ~self ~cmd:(selector "takeTraitsFrom:") ~typ:(id @-> returning (void)) x
let tapHighlightViewRect self = msg_send ~self ~cmd:(selector "tapHighlightViewRect") ~typ:(returning (CGRect.t))
let targetForAction x ~withSender self = msg_send ~self ~cmd:(selector "targetForAction:withSender:") ~typ:(_SEL @-> id @-> returning (id)) x withSender
let targetForActionForWebView x ~withSender self = msg_send ~self ~cmd:(selector "targetForActionForWebView:withSender:") ~typ:(_SEL @-> id @-> returning (id)) x withSender
let teardownDragAndDropInteractions self = msg_send ~self ~cmd:(selector "teardownDragAndDropInteractions") ~typ:(returning (void))
let teardownTextIndicatorLayer self = msg_send ~self ~cmd:(selector "teardownTextIndicatorLayer") ~typ:(returning (void))
let textColorForCaretSelection self = msg_send ~self ~cmd:(selector "textColorForCaretSelection") ~typ:(returning (id))
let textContentTypeForTesting self = msg_send ~self ~cmd:(selector "textContentTypeForTesting") ~typ:(returning (id))
let textEffectsWindow self = msg_send ~self ~cmd:(selector "textEffectsWindow") ~typ:(returning (id))
let textFirstRect self = msg_send ~self ~cmd:(selector "textFirstRect") ~typ:(returning (CGRect.t))
let textInRange x self = msg_send ~self ~cmd:(selector "textInRange:") ~typ:(id @-> returning (id)) x
let textInputTraits self = msg_send ~self ~cmd:(selector "textInputTraits") ~typ:(returning (id))
let textInteractionAssistant self = msg_send ~self ~cmd:(selector "textInteractionAssistant") ~typ:(returning (id))
let textInteractionGesture x ~shouldBeginAtPoint self = msg_send ~self ~cmd:(selector "textInteractionGesture:shouldBeginAtPoint:") ~typ:(llong @-> CGPoint.t @-> returning (bool)) x shouldBeginAtPoint
let textLastRect self = msg_send ~self ~cmd:(selector "textLastRect") ~typ:(returning (CGRect.t))
let textRangeFromPosition x ~toPosition self = msg_send ~self ~cmd:(selector "textRangeFromPosition:toPosition:") ~typ:(id @-> id @-> returning (id)) x toPosition
let textStylingAtPosition x ~inDirection self = msg_send ~self ~cmd:(selector "textStylingAtPosition:inDirection:") ~typ:(id @-> llong @-> returning (id)) x inDirection
let timePickerValueHour self = msg_send ~self ~cmd:(selector "timePickerValueHour") ~typ:(returning (double))
let timePickerValueMinute self = msg_send ~self ~cmd:(selector "timePickerValueMinute") ~typ:(returning (double))
let tintColorDidChange self = msg_send ~self ~cmd:(selector "tintColorDidChange") ~typ:(returning (void))
let toggleBoldface x self = msg_send ~self ~cmd:(selector "toggleBoldface:") ~typ:(id @-> returning (void)) x
let toggleBoldfaceForWebView x self = msg_send ~self ~cmd:(selector "toggleBoldfaceForWebView:") ~typ:(id @-> returning (void)) x
let toggleItalics x self = msg_send ~self ~cmd:(selector "toggleItalics:") ~typ:(id @-> returning (void)) x
let toggleItalicsForWebView x self = msg_send ~self ~cmd:(selector "toggleItalicsForWebView:") ~typ:(id @-> returning (void)) x
let toggleStrikeThroughForWebView x self = msg_send ~self ~cmd:(selector "toggleStrikeThroughForWebView:") ~typ:(id @-> returning (void)) x
let toggleUnderline x self = msg_send ~self ~cmd:(selector "toggleUnderline:") ~typ:(id @-> returning (void)) x
let toggleUnderlineForWebView x self = msg_send ~self ~cmd:(selector "toggleUnderlineForWebView:") ~typ:(id @-> returning (void)) x
let tokenizer self = msg_send ~self ~cmd:(selector "tokenizer") ~typ:(returning (id))
let touchActionActiveTouches self = msg_send ~self ~cmd:(selector "touchActionActiveTouches") ~typ:(returning (id))
let touchEventGestureRecognizer self = msg_send ~self ~cmd:(selector "touchEventGestureRecognizer") ~typ:(returning (id))
let undoManagerForWebView self = msg_send ~self ~cmd:(selector "undoManagerForWebView") ~typ:(returning (id))
let unmarkText self = msg_send ~self ~cmd:(selector "unmarkText") ~typ:(returning (void))
let unobscuredContentRect self = msg_send ~self ~cmd:(selector "unobscuredContentRect") ~typ:(returning (CGRect.t))
let unoccludedWindowBoundsForActionSheetAssistant x self = msg_send ~self ~cmd:(selector "unoccludedWindowBoundsForActionSheetAssistant:") ~typ:(id @-> returning (CGRect.t)) x
let unscaledView self = msg_send ~self ~cmd:(selector "unscaledView") ~typ:(returning (id))
let unsuppressSoftwareKeyboardUsingLastAutocorrectionContextIfNeeded self = msg_send ~self ~cmd:(selector "unsuppressSoftwareKeyboardUsingLastAutocorrectionContextIfNeeded") ~typ:(returning (void))
let updateCurrentFocusedElementInformation x self = msg_send ~self ~cmd:(selector "updateCurrentFocusedElementInformation:") ~typ:(ptr (void) @-> returning (void)) x
let updateFocusedElementFocusedWithDataListDropdown x self = msg_send ~self ~cmd:(selector "updateFocusedElementFocusedWithDataListDropdown:") ~typ:(bool @-> returning (void)) x
let updateFocusedElementSelectedIndex x ~allowsMultipleSelection self = msg_send ~self ~cmd:(selector "updateFocusedElementSelectedIndex:allowsMultipleSelection:") ~typ:(uint @-> bool @-> returning (void)) x allowsMultipleSelection
let updateFocusedElementValue x self = msg_send ~self ~cmd:(selector "updateFocusedElementValue:") ~typ:(id @-> returning (void)) x
let updateFocusedElementValueAsColor x self = msg_send ~self ~cmd:(selector "updateFocusedElementValueAsColor:") ~typ:(id @-> returning (void)) x
let updatePositionInformationForActionSheetAssistant x self = msg_send ~self ~cmd:(selector "updatePositionInformationForActionSheetAssistant:") ~typ:(id @-> returning (void)) x
let updateSelectionWithExtentPoint x ~completionHandler self = msg_send ~self ~cmd:(selector "updateSelectionWithExtentPoint:completionHandler:") ~typ:(CGPoint.t @-> ptr void @-> returning (void)) x completionHandler
let updateSelectionWithExtentPoint' x ~withBoundary ~completionHandler self = msg_send ~self ~cmd:(selector "updateSelectionWithExtentPoint:withBoundary:completionHandler:") ~typ:(CGPoint.t @-> llong @-> ptr void @-> returning (void)) x withBoundary completionHandler
let updateSoftwareKeyboardSuppressionStateFromWebView self = msg_send ~self ~cmd:(selector "updateSoftwareKeyboardSuppressionStateFromWebView") ~typ:(returning (void))
let updateTextSuggestionsForInputDelegate self = msg_send ~self ~cmd:(selector "updateTextSuggestionsForInputDelegate") ~typ:(returning (void))
let webSelectionRects self = msg_send ~self ~cmd:(selector "webSelectionRects") ~typ:(returning (id))
let webSelectionRectsForSelectionGeometries x self = msg_send ~self ~cmd:(selector "webSelectionRectsForSelectionGeometries:") ~typ:(ptr (void) @-> returning (id)) x
let webView self = msg_send ~self ~cmd:(selector "webView") ~typ:(returning (id))
let webViewUIDelegate self = msg_send ~self ~cmd:(selector "webViewUIDelegate") ~typ:(returning (id))
let willFinishIgnoringCalloutBarFadeAfterPerformingAction self = msg_send ~self ~cmd:(selector "willFinishIgnoringCalloutBarFadeAfterPerformingAction") ~typ:(returning (void))
let willMoveToWindow x self = msg_send ~self ~cmd:(selector "willMoveToWindow:") ~typ:(id @-> returning (void)) x
let willStartZoomOrScroll self = msg_send ~self ~cmd:(selector "willStartZoomOrScroll") ~typ:(returning (void))
let wordContainingCaretSelection self = msg_send ~self ~cmd:(selector "wordContainingCaretSelection") ~typ:(returning (id))
let wordRangeContainingCaretSelection self = msg_send ~self ~cmd:(selector "wordRangeContainingCaretSelection") ~typ:(returning (id))