(* auto-generated, do not modify *)

open Runtime
open Objc

[@@@ocaml.warning "-33"]
open Foundation

let _class_ = get_class "UITextInteractionAssistant"

let activate self = msg_send ~self ~cmd:(selector "activate") ~typ:(returning (void))
let activateSelection self = msg_send ~self ~cmd:(selector "activateSelection") ~typ:(returning (void))
let activeSelectionController self = msg_send ~self ~cmd:(selector "activeSelectionController") ~typ:(returning (id))
let addGestureRecognizersToView x self = msg_send ~self ~cmd:(selector "addGestureRecognizersToView:") ~typ:(id @-> returning (void)) x
let attach self = msg_send ~self ~cmd:(selector "attach") ~typ:(returning (void))
let attributedTextInRange x self = msg_send ~self ~cmd:(selector "attributedTextInRange:") ~typ:(id @-> returning (id)) x
let autoscrollUntransformedExtentPoint self = msg_send ~self ~cmd:(selector "autoscrollUntransformedExtentPoint") ~typ:(returning (CGPoint.t))
let autoscrollWillNotStart self = msg_send ~self ~cmd:(selector "autoscrollWillNotStart") ~typ:(returning (void))
let autoscrolled self = msg_send ~self ~cmd:(selector "autoscrolled") ~typ:(returning (bool))
let beginFloatingCursorAtPoint x self = msg_send ~self ~cmd:(selector "beginFloatingCursorAtPoint:") ~typ:(CGPoint.t @-> returning (void)) x
let canBeginDragCursor x self = msg_send ~self ~cmd:(selector "canBeginDragCursor:") ~typ:(id @-> returning (void)) x
let canShowSelectionCommands self = msg_send ~self ~cmd:(selector "canShowSelectionCommands") ~typ:(returning (bool))
let cancelAutoscroll self = msg_send ~self ~cmd:(selector "cancelAutoscroll") ~typ:(returning (void))
let checkEditabilityAndSetFirstResponderIfNecessary self = msg_send ~self ~cmd:(selector "checkEditabilityAndSetFirstResponderIfNecessary") ~typ:(returning (void))
let clearGestureRecognizers self = msg_send ~self ~cmd:(selector "clearGestureRecognizers") ~typ:(returning (void))
let clearGestureRecognizers' x self = msg_send ~self ~cmd:(selector "clearGestureRecognizers:") ~typ:(bool @-> returning (void)) x
let clearSelection self = msg_send ~self ~cmd:(selector "clearSelection") ~typ:(returning (void))
let clearStashedSelection self = msg_send ~self ~cmd:(selector "clearStashedSelection") ~typ:(returning (void))
let configureForHighlightMode self = msg_send ~self ~cmd:(selector "configureForHighlightMode") ~typ:(returning (void))
let configureForPencilDeletionPreviewMode self = msg_send ~self ~cmd:(selector "configureForPencilDeletionPreviewMode") ~typ:(returning (void))
let configureForPencilHighlightMode self = msg_send ~self ~cmd:(selector "configureForPencilHighlightMode") ~typ:(returning (void))
let configureForReplacementMode self = msg_send ~self ~cmd:(selector "configureForReplacementMode") ~typ:(returning (void))
let configureForSelectionMode self = msg_send ~self ~cmd:(selector "configureForSelectionMode") ~typ:(returning (void))
let constrainedPoint x self = msg_send ~self ~cmd:(selector "constrainedPoint:") ~typ:(CGPoint.t @-> returning (CGPoint.t)) x
let containerAllowsSelection self = msg_send ~self ~cmd:(selector "containerAllowsSelection") ~typ:(returning (bool))
let containerAllowsSelectionTintOnly self = msg_send ~self ~cmd:(selector "containerAllowsSelectionTintOnly") ~typ:(returning (bool))
let containerIsBrowserView self = msg_send ~self ~cmd:(selector "containerIsBrowserView") ~typ:(returning (bool))
let containerIsTextField self = msg_send ~self ~cmd:(selector "containerIsTextField") ~typ:(returning (bool))
let currentCursorBehavior self = msg_send ~self ~cmd:(selector "currentCursorBehavior") ~typ:(returning (llong))
let currentDraggedHandle self = msg_send ~self ~cmd:(selector "currentDraggedHandle") ~typ:(returning (ullong))
let cursorBlinks self = msg_send ~self ~cmd:(selector "cursorBlinks") ~typ:(returning (bool))
let cursorVisible self = msg_send ~self ~cmd:(selector "cursorVisible") ~typ:(returning (bool))
let deactivateSelection self = msg_send ~self ~cmd:(selector "deactivateSelection") ~typ:(returning (void))
let dealloc self = msg_send ~self ~cmd:(selector "dealloc") ~typ:(returning (void))
let detach self = msg_send ~self ~cmd:(selector "detach") ~typ:(returning (void))
let detach' x self = msg_send ~self ~cmd:(selector "detach:") ~typ:(bool @-> returning (void)) x
let didEndScrollingOrZooming self = msg_send ~self ~cmd:(selector "didEndScrollingOrZooming") ~typ:(returning (void))
let didEndSelectionInteraction self = msg_send ~self ~cmd:(selector "didEndSelectionInteraction") ~typ:(returning (void))
let didPerformLoupeSelectionHandoff self = msg_send ~self ~cmd:(selector "didPerformLoupeSelectionHandoff") ~typ:(returning (bool))
let didUseStashedSelection self = msg_send ~self ~cmd:(selector "didUseStashedSelection") ~typ:(returning (bool))
let doubleTapGesture self = msg_send ~self ~cmd:(selector "doubleTapGesture") ~typ:(returning (id))
let endFloatingCursor self = msg_send ~self ~cmd:(selector "endFloatingCursor") ~typ:(returning (void))
let expectingCommit self = msg_send ~self ~cmd:(selector "expectingCommit") ~typ:(returning (bool))
let extendSelectionToLoupeOrSetToPoint x self = msg_send ~self ~cmd:(selector "extendSelectionToLoupeOrSetToPoint:") ~typ:(CGPoint.t @-> returning (void)) x
let extendSelectionToPoint x self = msg_send ~self ~cmd:(selector "extendSelectionToPoint:") ~typ:(CGPoint.t @-> returning (void)) x
let externalInteractions self = msg_send ~self ~cmd:(selector "externalInteractions") ~typ:(returning (id))
let externalTextInput self = msg_send ~self ~cmd:(selector "externalTextInput") ~typ:(returning (bool))
let fieldEditor self = msg_send ~self ~cmd:(selector "fieldEditor") ~typ:(returning (id))
let forcePressGesture self = msg_send ~self ~cmd:(selector "forcePressGesture") ~typ:(returning (id))
let generatorForRange x ~withOptions self = msg_send ~self ~cmd:(selector "generatorForRange:withOptions:") ~typ:(id @-> ullong @-> returning (id)) x withOptions
let ghostAppearance self = msg_send ~self ~cmd:(selector "ghostAppearance") ~typ:(returning (bool))
let grabberSuppressionAssertion self = msg_send ~self ~cmd:(selector "grabberSuppressionAssertion") ~typ:(returning (id))
let handleMultilingualAlternativeWithString x ~range self = msg_send ~self ~cmd:(selector "handleMultilingualAlternativeWithString:range:") ~typ:(id @-> id @-> returning (bool)) x range
let hasActiveSelectionInteraction self = msg_send ~self ~cmd:(selector "hasActiveSelectionInteraction") ~typ:(returning (bool))
let hasReplacements self = msg_send ~self ~cmd:(selector "hasReplacements") ~typ:(returning (bool))
let inGesture self = msg_send ~self ~cmd:(selector "inGesture") ~typ:(returning (bool))
let initWithResponder x self = msg_send ~self ~cmd:(selector "initWithResponder:") ~typ:(id @-> returning (id)) x
let initWithView x self = msg_send ~self ~cmd:(selector "initWithView:") ~typ:(id @-> returning (id)) x
let initWithView' x ~textInteractionMode self = msg_send ~self ~cmd:(selector "initWithView:textInteractionMode:") ~typ:(id @-> llong @-> returning (id)) x textInteractionMode
let interactions self = msg_send ~self ~cmd:(selector "interactions") ~typ:(returning (id))
let invalidate self = msg_send ~self ~cmd:(selector "invalidate") ~typ:(returning (void))
let isInteractiveSelectionDisabled self = msg_send ~self ~cmd:(selector "isInteractiveSelectionDisabled") ~typ:(returning (bool))
let isValid self = msg_send ~self ~cmd:(selector "isValid") ~typ:(returning (bool))
let keyboardSuppressionAssertion self = msg_send ~self ~cmd:(selector "keyboardSuppressionAssertion") ~typ:(returning (id))
let layoutChangedByScrolling x self = msg_send ~self ~cmd:(selector "layoutChangedByScrolling:") ~typ:(bool @-> returning (void)) x
let linkInteraction self = msg_send ~self ~cmd:(selector "linkInteraction") ~typ:(returning (id))
let lollipopGestureWithState x ~location ~locationOfFirstTouch ~forTouchType self = msg_send ~self ~cmd:(selector "lollipopGestureWithState:location:locationOfFirstTouch:forTouchType:") ~typ:(llong @-> CGPoint.t @-> CGPoint.t @-> llong @-> returning (void)) x location locationOfFirstTouch forTouchType
let loupeGesture self = msg_send ~self ~cmd:(selector "loupeGesture") ~typ:(returning (id))
let loupeGestureEndPoint self = msg_send ~self ~cmd:(selector "loupeGestureEndPoint") ~typ:(returning (CGPoint.t))
let loupeGestureWithState x ~location ~translation ~velocity ~modifierFlags ~shouldCancel self = msg_send ~self ~cmd:(selector "loupeGestureWithState:location:translation:velocity:modifierFlags:shouldCancel:") ~typ:(llong @-> ptr void @-> ptr void @-> ptr void @-> llong @-> ptr (bool) @-> returning (void)) x location translation velocity modifierFlags shouldCancel
let loupeMagnifierWithState x ~atPoint self = msg_send ~self ~cmd:(selector "loupeMagnifierWithState:atPoint:") ~typ:(llong @-> CGPoint.t @-> returning (void)) x atPoint
let needsGestureUpdate self = msg_send ~self ~cmd:(selector "needsGestureUpdate") ~typ:(returning (bool))
let notifyKeyboardSelectionChanged self = msg_send ~self ~cmd:(selector "notifyKeyboardSelectionChanged") ~typ:(returning (void))
let pointerInteraction x ~styleForRegion self = msg_send ~self ~cmd:(selector "pointerInteraction:styleForRegion:") ~typ:(id @-> id @-> returning (id)) x styleForRegion
let pointerInteraction1 x ~regionForRequest ~defaultRegion self = msg_send ~self ~cmd:(selector "pointerInteraction:regionForRequest:defaultRegion:") ~typ:(id @-> id @-> id @-> returning (id)) x regionForRequest defaultRegion
let pointerInteraction2 x ~willEnterRegion ~animator self = msg_send ~self ~cmd:(selector "pointerInteraction:willEnterRegion:animator:") ~typ:(id @-> id @-> id @-> returning (void)) x willEnterRegion animator
let pointerInteraction3 x ~willExitRegion ~animator self = msg_send ~self ~cmd:(selector "pointerInteraction:willExitRegion:animator:") ~typ:(id @-> id @-> id @-> returning (void)) x willExitRegion animator
let rangeForTextReplacement x self = msg_send ~self ~cmd:(selector "rangeForTextReplacement:") ~typ:(id @-> returning (id)) x
let rangeSelectionCanceled self = msg_send ~self ~cmd:(selector "rangeSelectionCanceled") ~typ:(returning (void))
let rangeSelectionEnded x self = msg_send ~self ~cmd:(selector "rangeSelectionEnded:") ~typ:(CGPoint.t @-> returning (void)) x
let rangeSelectionMoved x ~withTouchPoint self = msg_send ~self ~cmd:(selector "rangeSelectionMoved:withTouchPoint:") ~typ:(CGPoint.t @-> CGPoint.t @-> returning (void)) x withTouchPoint
let rangeSelectionStarted x self = msg_send ~self ~cmd:(selector "rangeSelectionStarted:") ~typ:(CGPoint.t @-> returning (void)) x
let rangedMagnifierWithState x ~atPoint self = msg_send ~self ~cmd:(selector "rangedMagnifierWithState:atPoint:") ~typ:(llong @-> CGPoint.t @-> returning (void)) x atPoint
let requiresImmediateUpdate self = msg_send ~self ~cmd:(selector "requiresImmediateUpdate") ~typ:(returning (bool))
let resetWillHandoffLoupeMagnifier self = msg_send ~self ~cmd:(selector "resetWillHandoffLoupeMagnifier") ~typ:(returning (void))
let resignedFirstResponder self = msg_send ~self ~cmd:(selector "resignedFirstResponder") ~typ:(returning (void))
let scheduleChineseTransliteration self = msg_send ~self ~cmd:(selector "scheduleChineseTransliteration") ~typ:(returning (void))
let scheduleDictationReplacementsForAlternatives x ~range self = msg_send ~self ~cmd:(selector "scheduleDictationReplacementsForAlternatives:range:") ~typ:(id @-> id @-> returning (void)) x range
let scheduleReplacements self = msg_send ~self ~cmd:(selector "scheduleReplacements") ~typ:(returning (void))
let scheduleReplacementsForRange x ~withOptions self = msg_send ~self ~cmd:(selector "scheduleReplacementsForRange:withOptions:") ~typ:(id @-> ullong @-> returning (bool)) x withOptions
let scheduleReplacementsWithOptions x self = msg_send ~self ~cmd:(selector "scheduleReplacementsWithOptions:") ~typ:(ullong @-> returning (void)) x
let scrollSelectionToVisible self = msg_send ~self ~cmd:(selector "scrollSelectionToVisible") ~typ:(returning (void))
let scrollSelectionToVisible' x self = msg_send ~self ~cmd:(selector "scrollSelectionToVisible:") ~typ:(bool @-> returning (void)) x
let scrollView self = msg_send ~self ~cmd:(selector "scrollView") ~typ:(returning (id))
let selectAll x self = msg_send ~self ~cmd:(selector "selectAll:") ~typ:(id @-> returning (void)) x
let selectWord self = msg_send ~self ~cmd:(selector "selectWord") ~typ:(returning (void))
let selectWordWithoutShowingCommands self = msg_send ~self ~cmd:(selector "selectWordWithoutShowingCommands") ~typ:(returning (void))
let selectionAnimationDidStop self = msg_send ~self ~cmd:(selector "selectionAnimationDidStop") ~typ:(returning (void))
let selectionChanged self = msg_send ~self ~cmd:(selector "selectionChanged") ~typ:(returning (void))
let selectionInteractionClass self = msg_send ~self ~cmd:(selector "selectionInteractionClass") ~typ:(returning (_Class))
let selectionView self = msg_send ~self ~cmd:(selector "selectionView") ~typ:(returning (id))
let setAutoscrollUntransformedExtentPoint x self = msg_send ~self ~cmd:(selector "setAutoscrollUntransformedExtentPoint:") ~typ:(CGPoint.t @-> returning (void)) x
let setAutoscrolled x self = msg_send ~self ~cmd:(selector "setAutoscrolled:") ~typ:(bool @-> returning (void)) x
let setCursorBlinks x self = msg_send ~self ~cmd:(selector "setCursorBlinks:") ~typ:(bool @-> returning (void)) x
let setCursorVisible x self = msg_send ~self ~cmd:(selector "setCursorVisible:") ~typ:(bool @-> returning (void)) x
let setExpectingCommit x self = msg_send ~self ~cmd:(selector "setExpectingCommit:") ~typ:(bool @-> returning (void)) x
let setExternalInteractions x self = msg_send ~self ~cmd:(selector "setExternalInteractions:") ~typ:(id @-> returning (void)) x
let setFirstResponderIfNecessary self = msg_send ~self ~cmd:(selector "setFirstResponderIfNecessary") ~typ:(returning (void))
let setFirstResponderIfNecessaryActivatingSelection x self = msg_send ~self ~cmd:(selector "setFirstResponderIfNecessaryActivatingSelection:") ~typ:(bool @-> returning (void)) x
let setGestureRecognizers self = msg_send ~self ~cmd:(selector "setGestureRecognizers") ~typ:(returning (void))
let setGhostAppearance x self = msg_send ~self ~cmd:(selector "setGhostAppearance:") ~typ:(bool @-> returning (void)) x
let setGrabberSuppressionAssertion x self = msg_send ~self ~cmd:(selector "setGrabberSuppressionAssertion:") ~typ:(id @-> returning (void)) x
let setInGesture x self = msg_send ~self ~cmd:(selector "setInGesture:") ~typ:(bool @-> returning (void)) x
let setKeyboardSuppressionAssertion x self = msg_send ~self ~cmd:(selector "setKeyboardSuppressionAssertion:") ~typ:(id @-> returning (void)) x
let setLoupeGestureEndPoint x self = msg_send ~self ~cmd:(selector "setLoupeGestureEndPoint:") ~typ:(CGPoint.t @-> returning (void)) x
let setNeedsGestureUpdate x self = msg_send ~self ~cmd:(selector "setNeedsGestureUpdate:") ~typ:(bool @-> returning (void)) x
let setSelectionWithPoint x self = msg_send ~self ~cmd:(selector "setSelectionWithPoint:") ~typ:(CGPoint.t @-> returning (void)) x
let setSuppressSystemUI x self = msg_send ~self ~cmd:(selector "setSuppressSystemUI:") ~typ:(bool @-> returning (void)) x
let setWillHandoffLoupeMagnifier self = msg_send ~self ~cmd:(selector "setWillHandoffLoupeMagnifier") ~typ:(returning (void))
let shouldSuppressSelectionCommands self = msg_send ~self ~cmd:(selector "shouldSuppressSelectionCommands") ~typ:(returning (bool))
let showMultilingualDictationReplacementWithRange x self = msg_send ~self ~cmd:(selector "showMultilingualDictationReplacementWithRange:") ~typ:(id @-> returning (bool)) x
let singleTapGesture self = msg_send ~self ~cmd:(selector "singleTapGesture") ~typ:(returning (id))
let startAutoscroll x self = msg_send ~self ~cmd:(selector "startAutoscroll:") ~typ:(CGPoint.t @-> returning (void)) x
let stashCurrentSelection self = msg_send ~self ~cmd:(selector "stashCurrentSelection") ~typ:(returning (void))
let supportsIndirectInteractions self = msg_send ~self ~cmd:(selector "supportsIndirectInteractions") ~typ:(returning (bool))
let swallowsDoubleTapWithScale x ~atPoint self = msg_send ~self ~cmd:(selector "swallowsDoubleTapWithScale:atPoint:") ~typ:(double @-> CGPoint.t @-> returning (bool)) x atPoint
let textDocument self = msg_send ~self ~cmd:(selector "textDocument") ~typ:(returning (id))
let textSelectionView self = msg_send ~self ~cmd:(selector "textSelectionView") ~typ:(returning (id))
let updateAutoscroll x self = msg_send ~self ~cmd:(selector "updateAutoscroll:") ~typ:(id @-> returning (void)) x
let updateFloatingCursorAtPoint x self = msg_send ~self ~cmd:(selector "updateFloatingCursorAtPoint:") ~typ:(CGPoint.t @-> returning (void)) x
let updateFloatingCursorAtPoint' x ~velocity self = msg_send ~self ~cmd:(selector "updateFloatingCursorAtPoint:velocity:") ~typ:(CGPoint.t @-> CGPoint.t @-> returning (void)) x velocity
let updateSelectionWithPoint x self = msg_send ~self ~cmd:(selector "updateSelectionWithPoint:") ~typ:(CGPoint.t @-> returning (void)) x
let updateWithMagnifierTerminalPoint x self = msg_send ~self ~cmd:(selector "updateWithMagnifierTerminalPoint:") ~typ:(bool @-> returning (void)) x
let useGesturesForEditableContent self = msg_send ~self ~cmd:(selector "useGesturesForEditableContent") ~typ:(returning (bool))
let usesAsynchronousSelectionController self = msg_send ~self ~cmd:(selector "usesAsynchronousSelectionController") ~typ:(returning (bool))
let view self = msg_send ~self ~cmd:(selector "view") ~typ:(returning (id))
let viewConformsToAsynchronousInteractionProtocol self = msg_send ~self ~cmd:(selector "viewConformsToAsynchronousInteractionProtocol") ~typ:(returning (bool))
let viewCouldBecomeEditable x self = msg_send ~self ~cmd:(selector "viewCouldBecomeEditable:") ~typ:(id @-> returning (bool)) x
let wantsLinkInteraction self = msg_send ~self ~cmd:(selector "wantsLinkInteraction") ~typ:(returning (bool))
let willBeginFloatingCursor x self = msg_send ~self ~cmd:(selector "willBeginFloatingCursor:") ~typ:(bool @-> returning (void)) x
let willBeginSelectionInteraction self = msg_send ~self ~cmd:(selector "willBeginSelectionInteraction") ~typ:(returning (void))
let willHandoffLoupeMagnifier self = msg_send ~self ~cmd:(selector "willHandoffLoupeMagnifier") ~typ:(returning (bool))
let willStartScrollingOrZooming self = msg_send ~self ~cmd:(selector "willStartScrollingOrZooming") ~typ:(returning (void))