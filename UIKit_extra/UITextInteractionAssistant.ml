(* auto-generated, do not modify *)

open Runtime
open Objc

[@@@ocaml.warning "-33"]
open Foundation
open CoreAnimation
open CoreText

(** Apple docs: {{:https://developer.apple.com/documentation/uikit/uitextinteractionassistant?language=objc}UITextInteractionAssistant} *)

let self = get_class "UITextInteractionAssistant"

let activate self = msg_send ~self ~cmd:(selector "activate") ~typ:(returning void)
let activateSelection self = msg_send ~self ~cmd:(selector "activateSelection") ~typ:(returning void)
let activeSelectionController self = msg_send ~self ~cmd:(selector "activeSelectionController") ~typ:(returning id)
let addGestureRecognizersToView x self = msg_send ~self ~cmd:(selector "addGestureRecognizersToView:") ~typ:(id @-> returning void) x
let attach self = msg_send ~self ~cmd:(selector "attach") ~typ:(returning void)
let attributedTextInRange x self = msg_send ~self ~cmd:(selector "attributedTextInRange:") ~typ:(id @-> returning id) x
let autoscrollUntransformedExtentPoint self = msg_send_stret ~self ~cmd:(selector "autoscrollUntransformedExtentPoint") ~typ:(returning CGPoint.t) ~return_type:CGPoint.t
let autoscrollWillNotStart self = msg_send ~self ~cmd:(selector "autoscrollWillNotStart") ~typ:(returning void)
let autoscrolled self = msg_send ~self ~cmd:(selector "autoscrolled") ~typ:(returning bool)
let beginFloatingCursorAtPoint x self = msg_send ~self ~cmd:(selector "beginFloatingCursorAtPoint:") ~typ:(CGPoint.t @-> returning void) x
let canBeginDragCursor x self = msg_send ~self ~cmd:(selector "canBeginDragCursor:") ~typ:(id @-> returning void) x
let canShowSelectionCommands self = msg_send ~self ~cmd:(selector "canShowSelectionCommands") ~typ:(returning bool)
let cancelAutoscroll self = msg_send ~self ~cmd:(selector "cancelAutoscroll") ~typ:(returning void)
let checkEditabilityAndSetFirstResponderIfNecessary self = msg_send ~self ~cmd:(selector "checkEditabilityAndSetFirstResponderIfNecessary") ~typ:(returning void)
let clearGestureRecognizers self = msg_send ~self ~cmd:(selector "clearGestureRecognizers") ~typ:(returning void)
let clearGestureRecognizers' x self = msg_send ~self ~cmd:(selector "clearGestureRecognizers:") ~typ:(bool @-> returning void) x
let clearSelection self = msg_send ~self ~cmd:(selector "clearSelection") ~typ:(returning void)
let clearStashedSelection self = msg_send ~self ~cmd:(selector "clearStashedSelection") ~typ:(returning void)
let configureForHighlightMode self = msg_send ~self ~cmd:(selector "configureForHighlightMode") ~typ:(returning void)
let configureForPencilDeletionPreviewMode self = msg_send ~self ~cmd:(selector "configureForPencilDeletionPreviewMode") ~typ:(returning void)
let configureForPencilHighlightMode self = msg_send ~self ~cmd:(selector "configureForPencilHighlightMode") ~typ:(returning void)
let configureForReplacementMode self = msg_send ~self ~cmd:(selector "configureForReplacementMode") ~typ:(returning void)
let configureForSelectionMode self = msg_send ~self ~cmd:(selector "configureForSelectionMode") ~typ:(returning void)
let constrainedPoint x self = msg_send_stret ~self ~cmd:(selector "constrainedPoint:") ~typ:(CGPoint.t @-> returning CGPoint.t) ~return_type:CGPoint.t x
let containerAllowsSelection self = msg_send ~self ~cmd:(selector "containerAllowsSelection") ~typ:(returning bool)
let containerAllowsSelectionTintOnly self = msg_send ~self ~cmd:(selector "containerAllowsSelectionTintOnly") ~typ:(returning bool)
let containerIsBrowserView self = msg_send ~self ~cmd:(selector "containerIsBrowserView") ~typ:(returning bool)
let containerIsTextField self = msg_send ~self ~cmd:(selector "containerIsTextField") ~typ:(returning bool)
let currentCursorBehavior self = msg_send ~self ~cmd:(selector "currentCursorBehavior") ~typ:(returning llong)
let currentDraggedHandle self = msg_send ~self ~cmd:(selector "currentDraggedHandle") ~typ:(returning ullong)
let cursorBlinks self = msg_send ~self ~cmd:(selector "cursorBlinks") ~typ:(returning bool)
let cursorVisible self = msg_send ~self ~cmd:(selector "cursorVisible") ~typ:(returning bool)
let deactivateSelection self = msg_send ~self ~cmd:(selector "deactivateSelection") ~typ:(returning void)
let dealloc self = msg_send ~self ~cmd:(selector "dealloc") ~typ:(returning void)
let detach self = msg_send ~self ~cmd:(selector "detach") ~typ:(returning void)
let detach' x self = msg_send ~self ~cmd:(selector "detach:") ~typ:(bool @-> returning void) x
let didEndScrollingOrZooming self = msg_send ~self ~cmd:(selector "didEndScrollingOrZooming") ~typ:(returning void)
let didEndSelectionInteraction self = msg_send ~self ~cmd:(selector "didEndSelectionInteraction") ~typ:(returning void)
let didPerformLoupeSelectionHandoff self = msg_send ~self ~cmd:(selector "didPerformLoupeSelectionHandoff") ~typ:(returning bool)
let didUseStashedSelection self = msg_send ~self ~cmd:(selector "didUseStashedSelection") ~typ:(returning bool)
let doubleTapGesture self = msg_send ~self ~cmd:(selector "doubleTapGesture") ~typ:(returning id)
let endFloatingCursor self = msg_send ~self ~cmd:(selector "endFloatingCursor") ~typ:(returning void)
let expectingCommit self = msg_send ~self ~cmd:(selector "expectingCommit") ~typ:(returning bool)
let extendSelectionToLoupeOrSetToPoint x self = msg_send ~self ~cmd:(selector "extendSelectionToLoupeOrSetToPoint:") ~typ:(CGPoint.t @-> returning void) x
let extendSelectionToPoint x self = msg_send ~self ~cmd:(selector "extendSelectionToPoint:") ~typ:(CGPoint.t @-> returning void) x
let externalInteractions self = msg_send ~self ~cmd:(selector "externalInteractions") ~typ:(returning id)
let externalTextInput self = msg_send ~self ~cmd:(selector "externalTextInput") ~typ:(returning bool)
let fieldEditor self = msg_send ~self ~cmd:(selector "fieldEditor") ~typ:(returning id)
let forcePressGesture self = msg_send ~self ~cmd:(selector "forcePressGesture") ~typ:(returning id)
let generatorForRange x ~withOptions self = msg_send ~self ~cmd:(selector "generatorForRange:withOptions:") ~typ:(id @-> ullong @-> returning id) x (ULLong.of_int withOptions)
let ghostAppearance self = msg_send ~self ~cmd:(selector "ghostAppearance") ~typ:(returning bool)
let grabberSuppressionAssertion self = msg_send ~self ~cmd:(selector "grabberSuppressionAssertion") ~typ:(returning id)
let handleMultilingualAlternativeWithString x ~range self = msg_send ~self ~cmd:(selector "handleMultilingualAlternativeWithString:range:") ~typ:(id @-> id @-> returning bool) x range
let hasActiveSelectionInteraction self = msg_send ~self ~cmd:(selector "hasActiveSelectionInteraction") ~typ:(returning bool)
let hasReplacements self = msg_send ~self ~cmd:(selector "hasReplacements") ~typ:(returning bool)
let inGesture self = msg_send ~self ~cmd:(selector "inGesture") ~typ:(returning bool)
let initWithResponder x self = msg_send ~self ~cmd:(selector "initWithResponder:") ~typ:(id @-> returning id) x
let initWithView x self = msg_send ~self ~cmd:(selector "initWithView:") ~typ:(id @-> returning id) x
let initWithView' x ~textInteractionMode self = msg_send ~self ~cmd:(selector "initWithView:textInteractionMode:") ~typ:(id @-> llong @-> returning id) x (LLong.of_int textInteractionMode)
let interactions self = msg_send ~self ~cmd:(selector "interactions") ~typ:(returning id)
let invalidate self = msg_send ~self ~cmd:(selector "invalidate") ~typ:(returning void)
let isInteractiveSelectionDisabled self = msg_send ~self ~cmd:(selector "isInteractiveSelectionDisabled") ~typ:(returning bool)
let isValid self = msg_send ~self ~cmd:(selector "isValid") ~typ:(returning bool)
let keyboardSuppressionAssertion self = msg_send ~self ~cmd:(selector "keyboardSuppressionAssertion") ~typ:(returning id)
let layoutChangedByScrolling x self = msg_send ~self ~cmd:(selector "layoutChangedByScrolling:") ~typ:(bool @-> returning void) x
let linkInteraction self = msg_send ~self ~cmd:(selector "linkInteraction") ~typ:(returning id)
let lollipopGestureWithState x ~location ~locationOfFirstTouch ~forTouchType self = msg_send ~self ~cmd:(selector "lollipopGestureWithState:location:locationOfFirstTouch:forTouchType:") ~typ:(llong @-> CGPoint.t @-> CGPoint.t @-> llong @-> returning void) (LLong.of_int x) location locationOfFirstTouch (LLong.of_int forTouchType)
let loupeGesture self = msg_send ~self ~cmd:(selector "loupeGesture") ~typ:(returning id)
let loupeGestureEndPoint self = msg_send_stret ~self ~cmd:(selector "loupeGestureEndPoint") ~typ:(returning CGPoint.t) ~return_type:CGPoint.t
let loupeGestureWithState x ~location ~translation ~velocity ~modifierFlags ~shouldCancel self = msg_send ~self ~cmd:(selector "loupeGestureWithState:location:translation:velocity:modifierFlags:shouldCancel:") ~typ:(llong @-> (ptr void) @-> (ptr void) @-> (ptr void) @-> llong @-> (ptr bool) @-> returning void) (LLong.of_int x) location translation velocity (LLong.of_int modifierFlags) shouldCancel
let loupeMagnifierWithState x ~atPoint self = msg_send ~self ~cmd:(selector "loupeMagnifierWithState:atPoint:") ~typ:(llong @-> CGPoint.t @-> returning void) (LLong.of_int x) atPoint
let needsGestureUpdate self = msg_send ~self ~cmd:(selector "needsGestureUpdate") ~typ:(returning bool)
let notifyKeyboardSelectionChanged self = msg_send ~self ~cmd:(selector "notifyKeyboardSelectionChanged") ~typ:(returning void)
let pointerInteraction x ~styleForRegion self = msg_send ~self ~cmd:(selector "pointerInteraction:styleForRegion:") ~typ:(id @-> id @-> returning id) x styleForRegion
let pointerInteraction1 x ~regionForRequest ~defaultRegion self = msg_send ~self ~cmd:(selector "pointerInteraction:regionForRequest:defaultRegion:") ~typ:(id @-> id @-> id @-> returning id) x regionForRequest defaultRegion
let pointerInteraction2 x ~willEnterRegion ~animator self = msg_send ~self ~cmd:(selector "pointerInteraction:willEnterRegion:animator:") ~typ:(id @-> id @-> id @-> returning void) x willEnterRegion animator
let pointerInteraction3 x ~willExitRegion ~animator self = msg_send ~self ~cmd:(selector "pointerInteraction:willExitRegion:animator:") ~typ:(id @-> id @-> id @-> returning void) x willExitRegion animator
let rangeForTextReplacement x self = msg_send ~self ~cmd:(selector "rangeForTextReplacement:") ~typ:(id @-> returning id) x
let rangeSelectionCanceled self = msg_send ~self ~cmd:(selector "rangeSelectionCanceled") ~typ:(returning void)
let rangeSelectionEnded x self = msg_send ~self ~cmd:(selector "rangeSelectionEnded:") ~typ:(CGPoint.t @-> returning void) x
let rangeSelectionMoved x ~withTouchPoint self = msg_send ~self ~cmd:(selector "rangeSelectionMoved:withTouchPoint:") ~typ:(CGPoint.t @-> CGPoint.t @-> returning void) x withTouchPoint
let rangeSelectionStarted x self = msg_send ~self ~cmd:(selector "rangeSelectionStarted:") ~typ:(CGPoint.t @-> returning void) x
let rangedMagnifierWithState x ~atPoint self = msg_send ~self ~cmd:(selector "rangedMagnifierWithState:atPoint:") ~typ:(llong @-> CGPoint.t @-> returning void) (LLong.of_int x) atPoint
let requiresImmediateUpdate self = msg_send ~self ~cmd:(selector "requiresImmediateUpdate") ~typ:(returning bool)
let resetWillHandoffLoupeMagnifier self = msg_send ~self ~cmd:(selector "resetWillHandoffLoupeMagnifier") ~typ:(returning void)
let resignedFirstResponder self = msg_send ~self ~cmd:(selector "resignedFirstResponder") ~typ:(returning void)
let scheduleChineseTransliteration self = msg_send ~self ~cmd:(selector "scheduleChineseTransliteration") ~typ:(returning void)
let scheduleDictationReplacementsForAlternatives x ~range self = msg_send ~self ~cmd:(selector "scheduleDictationReplacementsForAlternatives:range:") ~typ:(id @-> id @-> returning void) x range
let scheduleReplacements self = msg_send ~self ~cmd:(selector "scheduleReplacements") ~typ:(returning void)
let scheduleReplacementsForRange x ~withOptions self = msg_send ~self ~cmd:(selector "scheduleReplacementsForRange:withOptions:") ~typ:(id @-> ullong @-> returning bool) x (ULLong.of_int withOptions)
let scheduleReplacementsWithOptions x self = msg_send ~self ~cmd:(selector "scheduleReplacementsWithOptions:") ~typ:(ullong @-> returning void) (ULLong.of_int x)
let scrollSelectionToVisible self = msg_send ~self ~cmd:(selector "scrollSelectionToVisible") ~typ:(returning void)
let scrollSelectionToVisible' x self = msg_send ~self ~cmd:(selector "scrollSelectionToVisible:") ~typ:(bool @-> returning void) x
let scrollView self = msg_send ~self ~cmd:(selector "scrollView") ~typ:(returning id)
let selectAll x self = msg_send ~self ~cmd:(selector "selectAll:") ~typ:(id @-> returning void) x
let selectWord self = msg_send ~self ~cmd:(selector "selectWord") ~typ:(returning void)
let selectWordWithoutShowingCommands self = msg_send ~self ~cmd:(selector "selectWordWithoutShowingCommands") ~typ:(returning void)
let selectionAnimationDidStop self = msg_send ~self ~cmd:(selector "selectionAnimationDidStop") ~typ:(returning void)
let selectionChanged self = msg_send ~self ~cmd:(selector "selectionChanged") ~typ:(returning void)
let selectionInteractionClass self = msg_send ~self ~cmd:(selector "selectionInteractionClass") ~typ:(returning _Class)
let selectionView self = msg_send ~self ~cmd:(selector "selectionView") ~typ:(returning id)
let setAutoscrollUntransformedExtentPoint x self = msg_send ~self ~cmd:(selector "setAutoscrollUntransformedExtentPoint:") ~typ:(CGPoint.t @-> returning void) x
let setAutoscrolled x self = msg_send ~self ~cmd:(selector "setAutoscrolled:") ~typ:(bool @-> returning void) x
let setCursorBlinks x self = msg_send ~self ~cmd:(selector "setCursorBlinks:") ~typ:(bool @-> returning void) x
let setCursorVisible x self = msg_send ~self ~cmd:(selector "setCursorVisible:") ~typ:(bool @-> returning void) x
let setExpectingCommit x self = msg_send ~self ~cmd:(selector "setExpectingCommit:") ~typ:(bool @-> returning void) x
let setExternalInteractions x self = msg_send ~self ~cmd:(selector "setExternalInteractions:") ~typ:(id @-> returning void) x
let setFirstResponderIfNecessary self = msg_send ~self ~cmd:(selector "setFirstResponderIfNecessary") ~typ:(returning void)
let setFirstResponderIfNecessaryActivatingSelection x self = msg_send ~self ~cmd:(selector "setFirstResponderIfNecessaryActivatingSelection:") ~typ:(bool @-> returning void) x
let setGestureRecognizers self = msg_send ~self ~cmd:(selector "setGestureRecognizers") ~typ:(returning void)
let setGhostAppearance x self = msg_send ~self ~cmd:(selector "setGhostAppearance:") ~typ:(bool @-> returning void) x
let setGrabberSuppressionAssertion x self = msg_send ~self ~cmd:(selector "setGrabberSuppressionAssertion:") ~typ:(id @-> returning void) x
let setInGesture x self = msg_send ~self ~cmd:(selector "setInGesture:") ~typ:(bool @-> returning void) x
let setKeyboardSuppressionAssertion x self = msg_send ~self ~cmd:(selector "setKeyboardSuppressionAssertion:") ~typ:(id @-> returning void) x
let setLoupeGestureEndPoint x self = msg_send ~self ~cmd:(selector "setLoupeGestureEndPoint:") ~typ:(CGPoint.t @-> returning void) x
let setNeedsGestureUpdate x self = msg_send ~self ~cmd:(selector "setNeedsGestureUpdate:") ~typ:(bool @-> returning void) x
let setSelectionWithPoint x self = msg_send ~self ~cmd:(selector "setSelectionWithPoint:") ~typ:(CGPoint.t @-> returning void) x
let setSuppressSystemUI x self = msg_send ~self ~cmd:(selector "setSuppressSystemUI:") ~typ:(bool @-> returning void) x
let setWillHandoffLoupeMagnifier self = msg_send ~self ~cmd:(selector "setWillHandoffLoupeMagnifier") ~typ:(returning void)
let shouldSuppressSelectionCommands self = msg_send ~self ~cmd:(selector "shouldSuppressSelectionCommands") ~typ:(returning bool)
let showMultilingualDictationReplacementWithRange x self = msg_send ~self ~cmd:(selector "showMultilingualDictationReplacementWithRange:") ~typ:(id @-> returning bool) x
let singleTapGesture self = msg_send ~self ~cmd:(selector "singleTapGesture") ~typ:(returning id)
let startAutoscroll x self = msg_send ~self ~cmd:(selector "startAutoscroll:") ~typ:(CGPoint.t @-> returning void) x
let stashCurrentSelection self = msg_send ~self ~cmd:(selector "stashCurrentSelection") ~typ:(returning void)
let supportsIndirectInteractions self = msg_send ~self ~cmd:(selector "supportsIndirectInteractions") ~typ:(returning bool)
let swallowsDoubleTapWithScale x ~atPoint self = msg_send ~self ~cmd:(selector "swallowsDoubleTapWithScale:atPoint:") ~typ:(double @-> CGPoint.t @-> returning bool) x atPoint
let textDocument self = msg_send ~self ~cmd:(selector "textDocument") ~typ:(returning id)
let textSelectionView self = msg_send ~self ~cmd:(selector "textSelectionView") ~typ:(returning id)
let updateAutoscroll x self = msg_send ~self ~cmd:(selector "updateAutoscroll:") ~typ:(id @-> returning void) x
let updateFloatingCursorAtPoint x self = msg_send ~self ~cmd:(selector "updateFloatingCursorAtPoint:") ~typ:(CGPoint.t @-> returning void) x
let updateFloatingCursorAtPoint' x ~velocity self = msg_send ~self ~cmd:(selector "updateFloatingCursorAtPoint:velocity:") ~typ:(CGPoint.t @-> CGPoint.t @-> returning void) x velocity
let updateSelectionWithPoint x self = msg_send ~self ~cmd:(selector "updateSelectionWithPoint:") ~typ:(CGPoint.t @-> returning void) x
let updateWithMagnifierTerminalPoint x self = msg_send ~self ~cmd:(selector "updateWithMagnifierTerminalPoint:") ~typ:(bool @-> returning void) x
let useGesturesForEditableContent self = msg_send ~self ~cmd:(selector "useGesturesForEditableContent") ~typ:(returning bool)
let usesAsynchronousSelectionController self = msg_send ~self ~cmd:(selector "usesAsynchronousSelectionController") ~typ:(returning bool)
let view self = msg_send ~self ~cmd:(selector "view") ~typ:(returning id)
let viewConformsToAsynchronousInteractionProtocol self = msg_send ~self ~cmd:(selector "viewConformsToAsynchronousInteractionProtocol") ~typ:(returning bool)
let viewCouldBecomeEditable x self = msg_send ~self ~cmd:(selector "viewCouldBecomeEditable:") ~typ:(id @-> returning bool) x
let wantsLinkInteraction self = msg_send ~self ~cmd:(selector "wantsLinkInteraction") ~typ:(returning bool)
let willBeginFloatingCursor x self = msg_send ~self ~cmd:(selector "willBeginFloatingCursor:") ~typ:(bool @-> returning void) x
let willBeginSelectionInteraction self = msg_send ~self ~cmd:(selector "willBeginSelectionInteraction") ~typ:(returning void)
let willHandoffLoupeMagnifier self = msg_send ~self ~cmd:(selector "willHandoffLoupeMagnifier") ~typ:(returning bool)
let willStartScrollingOrZooming self = msg_send ~self ~cmd:(selector "willStartScrollingOrZooming") ~typ:(returning void)